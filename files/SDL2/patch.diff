diff --git SDL2.orig/Android.mk SDL2.new/Android.mk
--- SDL2.orig/Android.mk
+++ SDL2.new/Android.mk
@@ -43,11 +43,12 @@ LOCAL_SRC_FILES := \
 	$(wildcard $(LOCAL_PATH)/src/timer/*.c) \
 	$(wildcard $(LOCAL_PATH)/src/timer/unix/*.c) \
 	$(wildcard $(LOCAL_PATH)/src/video/*.c) \
-	$(wildcard $(LOCAL_PATH)/src/video/android/*.c) \
-	$(wildcard $(LOCAL_PATH)/src/test/*.c))
+	$(wildcard $(LOCAL_PATH)/src/video/android/*.c)) \
+  #$(wildcard $(LOCAL_PATH)/src/test/*.c))
 
-LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DANDROID_JAVA_PACKAGE_PATH=com_apython_python_pythonhost_views_sdl
 LOCAL_LDLIBS := -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+LOCAL_SHARED_LIBRARIES := #pythonPatch
 
 include $(BUILD_SHARED_LIBRARY)
 
@@ -56,14 +57,14 @@ include $(BUILD_SHARED_LIBRARY)
 # SDL static library
 #
 ###########################
-
-LOCAL_MODULE := SDL2_static
-
-LOCAL_MODULE_FILENAME := libSDL2
-
-LOCAL_SRC_FILES += $(subst $(LOCAL_PATH)/,,$(LOCAL_PATH)/src/main/android/SDL_android_main.c)
-
-LOCAL_LDLIBS := 
-LOCAL_EXPORT_LDLIBS := -Wl,--undefined=Java_org_libsdl_app_SDLActivity_nativeInit -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
-
-include $(BUILD_STATIC_LIBRARY)
+#
+#LOCAL_MODULE := SDL2_static
+#
+#LOCAL_MODULE_FILENAME := libSDL2
+#
+#LOCAL_SRC_FILES += $(subst $(LOCAL_PATH)/,,$(LOCAL_PATH)/src/main/android/SDL_android_main.c)
+#
+#LOCAL_LDLIBS := 
+#LOCAL_EXPORT_LDLIBS := -Wl,--undefined=Java_org_libsdl_app_SDLActivity_nativeInit -ldl -lGLESv1_CM -lGLESv2 -llog -landroid
+#
+#include $(BUILD_STATIC_LIBRARY)
diff --git SDL2.orig/src/audio/android/SDL_androidaudio.c SDL2.new/src/audio/android/SDL_androidaudio.c
--- SDL2.orig/src/audio/android/SDL_androidaudio.c
+++ SDL2.new/src/audio/android/SDL_androidaudio.c
@@ -83,7 +83,9 @@ ANDROIDAUDIO_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)
     }
 
     /* TODO: pass in/return a (Java) device ID */
-    this->spec.samples = Android_JNI_OpenAudioDevice(iscapture, this->spec.freq, this->spec.format == AUDIO_U8 ? 0 : 1, this->spec.channels, this->spec.samples);
+    this->spec.samples = (Uint16) Android_JNI_OpenAudioDevice(
+            iscapture, this->spec.freq, this->spec.format == AUDIO_U8 ? SDL_FALSE : SDL_TRUE,
+            this->spec.channels, this->spec.samples);
 
     if (this->spec.samples == 0) {
         /* Init failed? */
@@ -122,8 +124,8 @@ ANDROIDAUDIO_FlushCapture(_THIS)
 static void
 ANDROIDAUDIO_CloseDevice(_THIS)
 {
-    /* At this point SDL_CloseAudioDevice via close_audio_device took care of terminating the audio thread
-       so it's safe to terminate the Java side buffer and AudioTrack
+    /* At this point SDL_CloseAudioDevice via close_audio_device took care of terminating the
+     * audio thread so it's safe to terminate the Java side buffer and AudioTrack
      */
     Android_JNI_CloseAudioDevice(this->iscapture);
     if (this->iscapture) {
@@ -165,7 +167,7 @@ void ANDROIDAUDIO_PauseDevices(void)
     /* TODO: Handle multiple devices? */
     struct SDL_PrivateAudioData *private;
     if(audioDevice != NULL && audioDevice->hidden != NULL) {
-        private = (struct SDL_PrivateAudioData *) audioDevice->hidden;
+        private = audioDevice->hidden;
         if (SDL_AtomicGet(&audioDevice->paused)) {
             /* The device is already paused, leave it alone */
             private->resume = SDL_FALSE;
@@ -178,7 +180,7 @@ void ANDROIDAUDIO_PauseDevices(void)
     }
 
     if(captureDevice != NULL && captureDevice->hidden != NULL) {
-        private = (struct SDL_PrivateAudioData *) captureDevice->hidden;
+        private = captureDevice->hidden;
         if (SDL_AtomicGet(&captureDevice->paused)) {
             /* The device is already paused, leave it alone */
             private->resume = SDL_FALSE;
@@ -197,7 +199,7 @@ void ANDROIDAUDIO_ResumeDevices(void)
     /* TODO: Handle multiple devices? */
     struct SDL_PrivateAudioData *private;
     if(audioDevice != NULL && audioDevice->hidden != NULL) {
-        private = (struct SDL_PrivateAudioData *) audioDevice->hidden;
+        private = audioDevice->hidden;
         if (private->resume) {
             SDL_AtomicSet(&audioDevice->paused, 0);
             private->resume = SDL_FALSE;
@@ -206,7 +208,7 @@ void ANDROIDAUDIO_ResumeDevices(void)
     }
 
     if(captureDevice != NULL && captureDevice->hidden != NULL) {
-        private = (struct SDL_PrivateAudioData *) captureDevice->hidden;
+        private = captureDevice->hidden;
         if (private->resume) {
             SDL_AtomicSet(&captureDevice->paused, 0);
             private->resume = SDL_FALSE;
diff --git SDL2.orig/src/core/android/SDL_android.c SDL2.new/src/core/android/SDL_android.c
--- SDL2.orig/src/core/android/SDL_android.c
+++ SDL2.new/src/core/android/SDL_android.c
@@ -31,6 +31,7 @@
 #include <EGL/egl.h>
 
 #include "../../events/SDL_events_c.h"
+#include "../../video/android/SDL_androidevents.h"
 #include "../../video/android/SDL_androidkeyboard.h"
 #include "../../video/android/SDL_androidmouse.h"
 #include "../../video/android/SDL_androidtouch.h"
@@ -42,11 +43,13 @@
 #include <pthread.h>
 #include <sys/types.h>
 #include <unistd.h>
-#define LOG_TAG "SDL_android"
-/* #define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__) */
-/* #define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__) */
-#define LOGI(...) do {} while (0)
-#define LOGE(...) do {} while (0)
+#include "SDL_main.h"
+
+#define LOG_TAG "SDL"
+#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
+#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
+//#define LOGI(...) do {} while (0)
+//#define LOGE(...) do {} while (0)
 
 /* Uncomment this to log messages entering and exiting methods in this file */
 /* #define DEBUG_JNI */
@@ -56,8 +59,6 @@ static void Android_JNI_ThreadDestroyed(void*);
 /*******************************************************************************
  This file links the Java side of Android with libsdl
 *******************************************************************************/
-#include <jni.h>
-#include <android/log.h>
 
 
 /*******************************************************************************
@@ -66,8 +67,9 @@ static void Android_JNI_ThreadDestroyed(void*);
 static pthread_key_t mThreadKey;
 static JavaVM* mJavaVM;
 
-/* Main activity */
-static jclass mActivityClass;
+/* Main classes to interact with the java side */
+static jclass sdlFragmentClass;
+static jclass sdlLibraryHandlerClass;
 
 /* method signatures */
 static jmethodID midGetNativeSurface;
@@ -80,11 +82,17 @@ static jmethodID midCaptureReadShortBuffer;
 static jmethodID midCaptureReadByteBuffer;
 static jmethodID midCaptureClose;
 static jmethodID midPollInputDevices;
+static jmethodID midCreateWindow;
+static jmethodID midSetPixelFormat;
+static jfieldID  fidNativeWindow;
 
 /* Accelerometer data storage */
 static float fLastAccelerometer[3];
 static SDL_bool bHasNewData;
 
+#define GET_SDL_WINDOW(env, jobject) \
+    (SDL_GetWindowFromID((*env)->GetLongField(env, jobject, fidNativeWindow)))
+
 /*******************************************************************************
                  Functions called by JNI
 *******************************************************************************/
@@ -104,58 +112,71 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)
      * Refer to http://developer.android.com/guide/practices/design/jni.html for the rationale behind this
      */
     if (pthread_key_create(&mThreadKey, Android_JNI_ThreadDestroyed) != 0) {
-        __android_log_print(ANDROID_LOG_ERROR, "SDL", "Error initializing pthread key");
+        LOGE("Error initializing pthread key");
     }
     Android_JNI_SetupThread();
-
+    
+    // TODO: Maybe implement some communication via sockets to the process which owns the vm
+    
     return JNI_VERSION_1_4;
 }
 
 /* Called before SDL_main() to initialize JNI bindings */
-JNIEXPORT void JNICALL SDL_Android_Init(JNIEnv* mEnv, jclass cls)
+JNIEXPORT void JNICALL SDL_Android_Init(JNIEnv* mEnv, jclass fragmentClass, jclass libHandlerClass)
 {
-    __android_log_print(ANDROID_LOG_INFO, "SDL", "SDL_Android_Init()");
+    LOGI("SDL_Android_Init()");
 
     Android_JNI_SetupThread();
 
-    mActivityClass = (jclass)((*mEnv)->NewGlobalRef(mEnv, cls));
+    sdlFragmentClass       = (jclass) ((*mEnv)->NewGlobalRef(mEnv, fragmentClass));
+    sdlLibraryHandlerClass = (jclass) ((*mEnv)->NewGlobalRef(mEnv, libHandlerClass));
 
-    midGetNativeSurface = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midGetNativeSurface = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass,
                                 "getNativeSurface","()Landroid/view/Surface;");
-    midAudioOpen = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioOpen = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "audioOpen", "(IZZI)I");
-    midAudioWriteShortBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioWriteShortBuffer = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "audioWriteShortBuffer", "([S)V");
-    midAudioWriteByteBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioWriteByteBuffer = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "audioWriteByteBuffer", "([B)V");
-    midAudioClose = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioClose = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "audioClose", "()V");
-    midCaptureOpen = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midCaptureOpen = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "captureOpen", "(IZZI)I");
-    midCaptureReadShortBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midCaptureReadShortBuffer = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "captureReadShortBuffer", "([SZ)I");
-    midCaptureReadByteBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midCaptureReadByteBuffer = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "captureReadByteBuffer", "([BZ)I");
-    midCaptureClose = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midCaptureClose = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
                                 "captureClose", "()V");
-    midPollInputDevices = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midPollInputDevices = (*mEnv)->GetStaticMethodID(mEnv, sdlFragmentClass,
                                 "pollInputDevices", "()V");
+    midCreateWindow = (*mEnv)->GetStaticMethodID(mEnv, sdlFragmentClass,
+                                "createWindow", "()Ljava/lang/Object;");
+    midSetPixelFormat = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass, "setPixelFormat", "(I)V");
+    fidNativeWindow = (*mEnv)->GetFieldID(mEnv, sdlFragmentClass, "nativeWindowId", "J");
 
     bHasNewData = SDL_FALSE;
 
-    if (!midGetNativeSurface ||
-       !midAudioOpen || !midAudioWriteShortBuffer || !midAudioWriteByteBuffer || !midAudioClose ||
-       !midCaptureOpen || !midCaptureReadShortBuffer || !midCaptureReadByteBuffer || !midCaptureClose ||
-       !midPollInputDevices) {
-        __android_log_print(ANDROID_LOG_WARN, "SDL", "SDL: Couldn't locate Java callbacks, check that they're named and typed correctly");
+    if (!midGetNativeSurface || !midAudioOpen || !midAudioWriteShortBuffer ||
+        !midAudioWriteByteBuffer || !midAudioClose || !midCaptureOpen ||
+        !midCaptureReadShortBuffer || !midCaptureReadByteBuffer || !midCaptureClose ||
+        !midPollInputDevices || !midSetPixelFormat || !midCreateWindow || !fidNativeWindow) {
+        LOGE("SDL: Couldn't locate Java callbacks, check that they're named and typed correctly");
     }
-    __android_log_print(ANDROID_LOG_INFO, "SDL", "SDL_Android_Init() finished!");
+    LOGI("SDL_Android_Init() finished!");
+}
+
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeInitLibrary)(
+        JNIEnv *env, jclass cls, jclass activityClass) {
+    /* This interface could expand with ABI negotiation, callbacks, etc. */
+    SDL_Android_Init(env, activityClass, cls);
+    SDL_SetMainReady();
 }
 
 /* Drop file */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeDropFile(
-                                    JNIEnv* env, jclass jcls,
-                                    jstring filename)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeDropFile)(
+        JNIEnv* env, jclass jcls, jstring filename)
 {
     const char *path = (*env)->GetStringUTFChars(env, filename, NULL);
     SDL_SendDropFile(NULL, path);
@@ -164,96 +185,153 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeDropFile(
 }
 
 /* Resize */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeResize(
-                                    JNIEnv* env, jclass jcls,
-                                    jint width, jint height, jint format, jfloat rate)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeResize)(
+        JNIEnv* env, jobject obj, jint width, jint height, jint format)
 {
-    Android_SetScreenResolution(width, height, format, rate);
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    Android_SetWindowSurfaceResolution(window, width, height, (Uint32) format);
+}
+
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeDisplayResize)(
+        JNIEnv* env, jclass cls, jint screenWidth, jint screenHeight, jfloat refreshRate)
+{
+    SDL_Android_SetScreenDimensions(screenWidth, screenHeight, refreshRate);
 }
 
 /* Paddown */
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_onNativePadDown(
-                                    JNIEnv* env, jclass jcls,
-                                    jint device_id, jint keycode)
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_onNativePadDown)(
+        JNIEnv* env, jclass jcls, jint device_id, jint keycode)
 {
     return Android_OnPadDown(device_id, keycode);
 }
 
 /* Padup */
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_onNativePadUp(
-                                   JNIEnv* env, jclass jcls,
-                                   jint device_id, jint keycode)
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_onNativePadUp)(
+        JNIEnv* env, jclass jcls, jint device_id, jint keycode)
 {
     return Android_OnPadUp(device_id, keycode);
 }
 
 /* Joy */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeJoy(
-                                    JNIEnv* env, jclass jcls,
-                                    jint device_id, jint axis, jfloat value)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeJoy)(
+        JNIEnv* env, jclass jcls, jint device_id, jint axis, jfloat value)
 {
     Android_OnJoy(device_id, axis, value);
 }
 
 /* POV Hat */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeHat(
-                                    JNIEnv* env, jclass jcls,
-                                    jint device_id, jint hat_id, jint x, jint y)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeHat)(
+        JNIEnv* env, jclass jcls, jint device_id, jint hat_id, jint x, jint y)
 {
     Android_OnHat(device_id, hat_id, x, y);
 }
 
 
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_nativeAddJoystick(
-    JNIEnv* env, jclass jcls,
-    jint device_id, jstring device_name, jint is_accelerometer, 
-    jint nbuttons, jint naxes, jint nhats, jint nballs)
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_nativeAddJoystick)(
+        JNIEnv* env, jclass jcls, jint device_id, jstring device_name, jint is_accelerometer,
+        jint nbuttons, jint naxes, jint nhats, jint nballs)
 {
     int retval;
     const char *name = (*env)->GetStringUTFChars(env, device_name, NULL);
 
-    retval = Android_AddJoystick(device_id, name, (SDL_bool) is_accelerometer, nbuttons, naxes, nhats, nballs);
+    retval = Android_AddJoystick(device_id, name, (SDL_bool) is_accelerometer,
+                                 nbuttons, naxes, nhats, nballs);
 
     (*env)->ReleaseStringUTFChars(env, device_name, name);
     
     return retval;
 }
 
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_nativeRemoveJoystick(
-    JNIEnv* env, jclass jcls, jint device_id)
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_nativeRemoveJoystick)(
+        JNIEnv* env, jclass jcls, jint device_id)
 {
     return Android_RemoveJoystick(device_id);
 }
 
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeHideWindow)(JNIEnv* env, jobject obj) {
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_MINIMIZED, 0, 0);
+}
 
-/* Surface Created */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeSurfaceChanged(JNIEnv* env, jclass jcls)
-{
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeRestoreWindow)(JNIEnv* env, jobject obj) {
     SDL_WindowData *data;
     SDL_VideoDevice *_this;
-
-    if (Android_Window == NULL || Android_Window->driverdata == NULL ) {
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    } else if (window->driverdata == NULL ) {
+        fprintf(stderr, "%s: SDL window is uninitialized!\n", __func__);
         return;
     }
     
-    _this =  SDL_GetVideoDevice();
-    data =  (SDL_WindowData *) Android_Window->driverdata;
+    _this = SDL_GetVideoDevice();
+    data = (SDL_WindowData *) window->driverdata;
     
     /* If the surface has been previously destroyed by onNativeSurfaceDestroyed, recreate it here */
-    if (data->egl_surface == EGL_NO_SURFACE) {
-        if(data->native_window) {
-            ANativeWindow_release(data->native_window);
-        }
-        data->native_window = Android_JNI_GetNativeWindow();
+    if (!data->native_window) {
+        fprintf(stderr, "Creating new surface!\n");
+//        SDL_EGL_MakeCurrent(_this, NULL, NULL);
+        data->native_window = Android_JNI_GetNativeWindow(obj);
+        EGLSurface oldSurface = data->egl_surface;
         data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);
-    }
+        fprintf(stderr, "New surface is %p\n", data->egl_surface);
     
-    /* GL Context handling is done in the event loop because this function is run from the Java thread */
+        restore_egl_context_window_id = SDL_GetWindowID(window);
+        SDL_Event event;
+        event.type = SDL_RENDER_DEVICE_RESET;
+        SDL_PushEvent(&event);
+        
+        SDL_SemWaitTimeout(context_restore_lock, 1000);
     
+        fprintf(stderr, "context_backup_lock wait over\n");
+        if (oldSurface != EGL_NO_SURFACE) {
+            SDL_EGL_DestroySurface(_this, oldSurface);
+        }
+    }
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESTORED, 0, 0);
+}
+
+JNIEXPORT void Android_JNI_ShowTextInputOnWindow(SDL_Rect *inputRect, jobject androidWindow);
+
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeWindowFocusChanged)(
+        JNIEnv* env, jobject obj, jboolean hasFocus) {
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    fprintf(stderr, "Window %d focus changed: %s\n", SDL_GetWindowID(window),
+            hasFocus == JNI_TRUE ? "SDL_WINDOWEVENT_FOCUS_GAINED" : "SDL_WINDOWEVENT_FOCUS_LOST");
+    SDL_SetKeyboardFocus(hasFocus == JNI_TRUE ? window : NULL);
+//    if (hasFocus) {
+//        SDL_Window* focusWindow = SDL_GetKeyboardFocus();
+//        if (SDL_GetWindowID(focusWindow) == SDL_GetWindowID(window)) {
+//            Android_JNI_ShowTextInputOnWindow(&((SDL_VideoData*) SDL_GetVideoDevice()->driverdata)->textRect, obj);
+//        }
+//    }
+}
+
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_nativeOnWindowClose)(JNIEnv* env, jclass obj)
+{
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_CLOSE, 0, 0);
 }
 
 /* Surface Destroyed */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeSurfaceDestroyed(JNIEnv* env, jclass jcls)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeSurfaceDestroyed)(JNIEnv* env, jobject obj)
 {
     /* We have to clear the current context and destroy the egl surface here
      * Otherwise there's BAD_NATIVE_WINDOW errors coming from eglCreateWindowSurface on resume
@@ -261,68 +339,94 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeSurfaceDestroyed(
      */
     SDL_WindowData *data;
     SDL_VideoDevice *_this;
-    
-    if (Android_Window == NULL || Android_Window->driverdata == NULL ) {
+
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    } else if (window->driverdata == NULL ) {
         return;
     }
-    
+
     _this =  SDL_GetVideoDevice();
-    data = (SDL_WindowData *) Android_Window->driverdata;
+    data = (SDL_WindowData *) window->driverdata;
+
+    /* Change the current surface to the pbuffer surface */
+    EGLSurface oldSurface = data->egl_surface;
+    data->egl_surface = SDL_EGL_CreateSurfaceWithoutWindow(_this);
     
-    if (data->egl_surface != EGL_NO_SURFACE) {
-        SDL_EGL_MakeCurrent(_this, NULL, NULL);
-        SDL_EGL_DestroySurface(_this, data->egl_surface);
-        data->egl_surface = EGL_NO_SURFACE;
+    fprintf(stderr, "Setting window to backup the egl context of to %d\n", SDL_GetWindowID(window));
+    backup_egl_context_window_id = SDL_GetWindowID(window);
+    SDL_Event event;
+    event.type = SDL_RENDER_DEVICE_RESET;
+    SDL_PushEvent(&event);
+    
+    SDL_SemWaitTimeout(context_backup_lock, 1000);
+    
+    fprintf(stderr, "context_backup_lock wait over\n");
+    
+    if (oldSurface != EGL_NO_SURFACE) {
+        SDL_EGL_DestroySurface(_this, oldSurface);
+    }
+    if (data->native_window) {
+        ANativeWindow_release(data->native_window);
+        data->native_window = NULL;
     }
     
-    /* GL Context handling is done in the event loop because this function is run from the Java thread */
-
 }
 
 /* Keydown */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyDown(
-                                    JNIEnv* env, jclass jcls, jint keycode)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeKeyDown)(
+        JNIEnv* env, jclass jcls, jint keycode)
 {
     Android_OnKeyDown(keycode);
 }
 
 /* Keyup */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyUp(
-                                    JNIEnv* env, jclass jcls, jint keycode)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeKeyUp)(
+        JNIEnv* env, jclass jcls, jint keycode)
 {
     Android_OnKeyUp(keycode);
 }
 
 /* Keyboard Focus Lost */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyboardFocusLost(
-                                    JNIEnv* env, jclass jcls)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeKeyboardFocusLost)(
+        JNIEnv* env, jclass jcls)
 {
-    /* Calling SDL_StopTextInput will take care of hiding the keyboard and cleaning up the DummyText widget */
+    /* Calling SDL_StopTextInput will take care of hiding the keyboard
+     * and cleaning up the DummyText widget */
     SDL_StopTextInput();
 }
 
 
 /* Touch */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeTouch(
-                                    JNIEnv* env, jclass jcls,
-                                    jint touch_device_id_in, jint pointer_finger_id_in,
-                                    jint action, jfloat x, jfloat y, jfloat p)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeTouch)(
+        JNIEnv* env, jobject obj, jint touch_device_id_in, jint pointer_finger_id_in,
+        jint action, jfloat x, jfloat y, jfloat p)
 {
-    Android_OnTouch(touch_device_id_in, pointer_finger_id_in, action, x, y, p);
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    Android_OnTouch(window, touch_device_id_in, pointer_finger_id_in, action, x, y, p);
 }
 
 /* Mouse */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeMouse(
-                                    JNIEnv* env, jclass jcls,
-                                    jint button, jint action, jfloat x, jfloat y)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeMouse)(
+        JNIEnv* env, jobject obj, jint button, jint action, jfloat x, jfloat y)
 {
-    Android_OnMouse(button, action, x, y);
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    Android_OnMouse(window, button, action, x, y);
 }
 
 /* Accelerometer */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeAccel(
-                                    JNIEnv* env, jclass jcls,
-                                    jfloat x, jfloat y, jfloat z)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeAccel)(
+        JNIEnv* env, jclass jcls, jfloat x, jfloat y, jfloat z)
 {
     fLastAccelerometer[0] = x;
     fLastAccelerometer[1] = y;
@@ -331,15 +435,13 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeAccel(
 }
 
 /* Low memory */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeLowMemory(
-                                    JNIEnv* env, jclass cls)
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeLowMemory)(JNIEnv* env, jclass cls)
 {
     SDL_SendAppEvent(SDL_APP_LOWMEMORY);
 }
 
 /* Quit */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeQuit(
-                                    JNIEnv* env, jclass cls)
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeQuit)(JNIEnv* env, jclass cls)
 {
     /* Discard previous events. The user should have handled state storage
      * in SDL_APP_WILLENTERBACKGROUND. After nativeQuit() is called, no
@@ -354,44 +456,32 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeQuit(
 }
 
 /* Pause */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativePause(
-                                    JNIEnv* env, jclass cls)
-{
-    __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "nativePause()");
-    if (Android_Window) {
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_FOCUS_LOST, 0, 0);
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_MINIMIZED, 0, 0);
-        SDL_SendAppEvent(SDL_APP_WILLENTERBACKGROUND);
-        SDL_SendAppEvent(SDL_APP_DIDENTERBACKGROUND);
-    
-        /* *After* sending the relevant events, signal the pause semaphore 
-         * so the event loop knows to pause and (optionally) block itself */
-        if (!SDL_SemValue(Android_PauseSem)) SDL_SemPost(Android_PauseSem);
-    }
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativePause)(JNIEnv* env, jclass cls)
+{
+    LOGI("nativePause()");
+    SDL_SendAppEvent(SDL_APP_WILLENTERBACKGROUND);
+    SDL_SendAppEvent(SDL_APP_DIDENTERBACKGROUND);
+
+    /* *After* sending the relevant events, signal the pause semaphore
+     * so the event loop knows to pause and (optionally) block itself */
+    if (!SDL_SemValue(Android_PauseSem)) SDL_SemPost(Android_PauseSem);
 }
 
 /* Resume */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeResume(
-                                    JNIEnv* env, jclass cls)
-{
-    __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "nativeResume()");
-
-    if (Android_Window) {
-        SDL_SendAppEvent(SDL_APP_WILLENTERFOREGROUND);
-        SDL_SendAppEvent(SDL_APP_DIDENTERFOREGROUND);
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_FOCUS_GAINED, 0, 0);
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_RESTORED, 0, 0);
-        /* Signal the resume semaphore so the event loop knows to resume and restore the GL Context
-         * We can't restore the GL Context here because it needs to be done on the SDL main thread
-         * and this function will be called from the Java thread instead.
-         */
-        if (!SDL_SemValue(Android_ResumeSem)) SDL_SemPost(Android_ResumeSem);
-    }
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeResume)(JNIEnv* env, jclass cls)
+{
+    LOGI("nativeResume()");
+    SDL_SendAppEvent(SDL_APP_WILLENTERFOREGROUND);
+    SDL_SendAppEvent(SDL_APP_DIDENTERFOREGROUND);
+    /* Signal the resume semaphore so the event loop knows to resume and restore the GL Context
+     * We can't restore the GL Context here because it needs to be done on the SDL main thread
+     * and this function will be called from the Java thread instead.
+     */
+    if (!SDL_SemValue(Android_ResumeSem)) SDL_SemPost(Android_ResumeSem);
 }
 
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeCommitText(
-                                    JNIEnv* env, jclass cls,
-                                    jstring text, jint newCursorPosition)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_nativeCommitText)(
+        JNIEnv* env, jobject obj, jstring text, jint newCursorPosition)
 {
     const char *utftext = (*env)->GetStringUTFChars(env, text, NULL);
 
@@ -400,9 +490,8 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeCommitText(
     (*env)->ReleaseStringUTFChars(env, text, utftext);
 }
 
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeSetComposingText(
-                                    JNIEnv* env, jclass cls,
-                                    jstring text, jint newCursorPosition)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_nativeSetComposingText)(
+        JNIEnv* env, jobject obj, jstring text, jint newCursorPosition)
 {
     const char *utftext = (*env)->GetStringUTFChars(env, text, NULL);
 
@@ -411,7 +500,8 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeSetComposing
     (*env)->ReleaseStringUTFChars(env, text, utftext);
 }
 
-JNIEXPORT jstring JNICALL Java_org_libsdl_app_SDLActivity_nativeGetHint(JNIEnv* env, jclass cls, jstring name) {
+JNIEXPORT jstring JNICALL NATIVE_FUNCTION(SDLWindowFragment_nativeGetHint)(
+        JNIEnv* env, jobject obj, jstring name) {
     const char *utfname = (*env)->GetStringUTFChars(env, name, NULL);
     const char *hint = SDL_GetHint(utfname);
 
@@ -469,34 +559,78 @@ static void LocalReferenceHolder_Cleanup(struct LocalReferenceHolder *refholder)
 
 static SDL_bool LocalReferenceHolder_IsActive(void)
 {
-    return s_active > 0;
+    return s_active > 0 ? SDL_TRUE : SDL_FALSE;
+}
+
+jobject Android_JNI_CreateWindow(SDL_Window* sdl_window) {
+    JNIEnv *env = Android_JNI_GetEnv();
+    jobject android_window = (*env)->CallStaticObjectMethod(env, sdlFragmentClass, midCreateWindow);
+    android_window = (*env)->NewGlobalRef(env, android_window);
+    if (android_window != NULL) {
+        fprintf(stderr, "Setting window Id on android window");
+        (*env)->SetLongField(env, android_window, fidNativeWindow, SDL_GetWindowID(sdl_window));
+    }
+    return android_window;
 }
 
-ANativeWindow* Android_JNI_GetNativeWindow(void)
+void Android_JNI_DestroyWindow(jobject android_window) {
+    JNIEnv *env = Android_JNI_GetEnv();
+    jmethodID midDestroyWindow = (*env)->GetMethodID(env, sdlFragmentClass, "destroy", "()V");
+    (*env)->CallVoidMethod(env, android_window, midDestroyWindow);
+    (*env)->DeleteGlobalRef(env, android_window);
+}
+
+ANativeWindow* Android_JNI_GetNativeWindow(jobject android_window)
 {
     ANativeWindow* anw;
     jobject s;
     JNIEnv *env = Android_JNI_GetEnv();
 
-    s = (*env)->CallStaticObjectMethod(env, mActivityClass, midGetNativeSurface);
+    s = (*env)->CallObjectMethod(env, android_window, midGetNativeSurface);
     anw = ANativeWindow_fromSurface(env, s);
     (*env)->DeleteLocalRef(env, s);
-  
+
     return anw;
 }
 
-void Android_JNI_SetActivityTitle(const char *title)
+void Android_JNI_SetWindowTitle(SDL_Window* window, const char *title)
 {
     jmethodID mid;
+    if (GET_ANDROID_WINDOW(window) == NULL) return;
     JNIEnv *mEnv = Android_JNI_GetEnv();
-    mid = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,"setActivityTitle","(Ljava/lang/String;)Z");
+    mid = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass, "setWindowTitle", "(Ljava/lang/String;)Z");
     if (mid) {
         jstring jtitle = (jstring)((*mEnv)->NewStringUTF(mEnv, title));
-        (*mEnv)->CallStaticBooleanMethod(mEnv, mActivityClass, mid, jtitle);
+        (*mEnv)->CallBooleanMethod(mEnv, GET_ANDROID_WINDOW(window), mid, jtitle);
         (*mEnv)->DeleteLocalRef(mEnv, jtitle);
     }
 }
 
+void Android_JNI_SetWindowIcon(SDL_Window* window, SDL_Surface* icon)
+{
+    jmethodID mid;
+    if (GET_ANDROID_WINDOW(window) == NULL) return;
+    JNIEnv *mEnv = Android_JNI_GetEnv();
+    mid = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass, "setWindowIcon", "([III)V");
+    if (mid) {
+        if (icon != NULL) {
+            SDL_assert(icon->format->format == SDL_PIXELFORMAT_ARGB8888); // TODO: Convert if wrong
+            int size = icon->w * icon->h;
+            jintArray iconData = (*mEnv)->NewIntArray(mEnv, size);
+            (*mEnv)->SetIntArrayRegion(mEnv, iconData, 0, size, icon->pixels);
+            (*mEnv)->CallVoidMethod(mEnv, GET_ANDROID_WINDOW(window), mid, iconData, icon->w, icon->h);
+            (*mEnv)->DeleteLocalRef(mEnv, iconData);
+        } else {
+            (*mEnv)->CallVoidMethod(mEnv, GET_ANDROID_WINDOW(window), mid, NULL, -1, -1);
+        }
+    }
+}
+
+void Android_JNI_SetPixelFormat(jobject android_window, int pixelFormat) {
+    JNIEnv *mEnv = Android_JNI_GetEnv();
+    (*mEnv)->CallVoidMethod(mEnv, android_window, midSetPixelFormat);
+}
+
 SDL_bool Android_JNI_GetAccelerometerValues(float values[3])
 {
     int i;
@@ -515,7 +649,8 @@ SDL_bool Android_JNI_GetAccelerometerValues(float values[3])
 
 static void Android_JNI_ThreadDestroyed(void* value)
 {
-    /* The thread is being destroyed, detach it from the Java VM and set the mThreadKey value to NULL as required */
+    /* The thread is being destroyed, detach it from the Java VM
+     * and set the mThreadKey value to NULL as required. */
     JNIEnv *env = (JNIEnv*) value;
     if (env != NULL) {
         (*mJavaVM)->DetachCurrentThread(mJavaVM);
@@ -536,6 +671,11 @@ JNIEnv* Android_JNI_GetEnv(void)
      * is a no-op.
      * Note: You can call this function any number of times for the same thread, there's no harm in it
      */
+     if (mJavaVM == NULL) {
+         LOGE("The current process is not attached to any JVM!");
+         SDL_SetError("The current process is not attached to any JVM!");
+         return NULL;
+     }
 
     JNIEnv *env;
     int status = (*mJavaVM)->AttachCurrentThread(mJavaVM, &env, NULL);
@@ -573,7 +713,8 @@ static void* audioBufferPinned = NULL;
 static jboolean captureBuffer16Bit = JNI_FALSE;
 static jobject captureBuffer = NULL;
 
-int Android_JNI_OpenAudioDevice(int iscapture, int sampleRate, int is16Bit, int channelCount, int desiredBufferFrames)
+int Android_JNI_OpenAudioDevice(int isCapture, int sampleRate, SDL_bool is16Bit,
+                                int channelCount, int desiredBufferFrames)
 {
     jboolean audioBufferStereo;
     int audioBufferFrames;
@@ -584,25 +725,30 @@ int Android_JNI_OpenAudioDevice(int iscapture, int sampleRate, int is16Bit, int
 
     if (!env) {
         LOGE("callback_handler: failed to attach current thread");
+        return 0;
     }
     Android_JNI_SetupThread();
 
-    audioBufferStereo = channelCount > 1;
+    audioBufferStereo = (jboolean) (channelCount > 1);
 
-    if (iscapture) {
-        __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "SDL audio: opening device for capture");
+    if (isCapture) {
+        LOGI("SDL audio: opening device for capture");
         captureBuffer16Bit = is16Bit;
-        if ((*env)->CallStaticIntMethod(env, mActivityClass, midCaptureOpen, sampleRate, audioBuffer16Bit, audioBufferStereo, desiredBufferFrames) != 0) {
+        if ((*env)->CallStaticIntMethod(
+                env, sdlLibraryHandlerClass, midCaptureOpen, sampleRate, audioBuffer16Bit,
+                audioBufferStereo, desiredBufferFrames) != 0) {
             /* Error during audio initialization */
-            __android_log_print(ANDROID_LOG_WARN, "SDL", "SDL audio: error on AudioRecord initialization!");
+            LOGE("SDL audio: error on AudioRecord initialization!");
             return 0;
         }
     } else {
-        __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "SDL audio: opening device for output");
+        LOGI("SDL audio: opening device for output");
         audioBuffer16Bit = is16Bit;
-        if ((*env)->CallStaticIntMethod(env, mActivityClass, midAudioOpen, sampleRate, audioBuffer16Bit, audioBufferStereo, desiredBufferFrames) != 0) {
+        if ((*env)->CallStaticIntMethod(
+                env, sdlLibraryHandlerClass, midAudioOpen, sampleRate, audioBuffer16Bit,
+                audioBufferStereo, desiredBufferFrames) != 0) {
             /* Error during audio initialization */
-            __android_log_print(ANDROID_LOG_WARN, "SDL", "SDL audio: error on AudioTrack initialization!");
+            LOGE("SDL audio: error on AudioTrack initialization!");
             return 0;
         }
     }
@@ -611,14 +757,16 @@ int Android_JNI_OpenAudioDevice(int iscapture, int sampleRate, int is16Bit, int
      * Android >= 4.2 due to a "stale global reference" error. So now we allocate this buffer directly from this side. */
 
     if (is16Bit) {
-        jshortArray audioBufferLocal = (*env)->NewShortArray(env, desiredBufferFrames * (audioBufferStereo ? 2 : 1));
+        jshortArray audioBufferLocal = (*env)->NewShortArray(
+                env, desiredBufferFrames * (audioBufferStereo ? 2 : 1));
         if (audioBufferLocal) {
             jbufobj = (*env)->NewGlobalRef(env, audioBufferLocal);
             (*env)->DeleteLocalRef(env, audioBufferLocal);
         }
     }
     else {
-        jbyteArray audioBufferLocal = (*env)->NewByteArray(env, desiredBufferFrames * (audioBufferStereo ? 2 : 1));
+        jbyteArray audioBufferLocal = (*env)->NewByteArray(
+                env, desiredBufferFrames * (audioBufferStereo ? 2 : 1));
         if (audioBufferLocal) {
             jbufobj = (*env)->NewGlobalRef(env, audioBufferLocal);
             (*env)->DeleteLocalRef(env, audioBufferLocal);
@@ -626,11 +774,11 @@ int Android_JNI_OpenAudioDevice(int iscapture, int sampleRate, int is16Bit, int
     }
 
     if (jbufobj == NULL) {
-        __android_log_print(ANDROID_LOG_WARN, "SDL", "SDL audio: could not allocate an audio buffer!");
+        LOGE("SDL audio: could not allocate an audio buffer!");
         return 0;
     }
 
-    if (iscapture) {
+    if (isCapture) {
         captureBuffer = jbufobj;
     } else {
         audioBuffer = jbufobj;
@@ -639,15 +787,17 @@ int Android_JNI_OpenAudioDevice(int iscapture, int sampleRate, int is16Bit, int
     isCopy = JNI_FALSE;
 
     if (is16Bit) {
-        if (!iscapture) {
-            audioBufferPinned = (*env)->GetShortArrayElements(env, (jshortArray)audioBuffer, &isCopy);
+        if (!isCapture) {
+            audioBufferPinned = (*env)->GetShortArrayElements(env, (jshortArray) audioBuffer,
+                                                              &isCopy);
         }
-        audioBufferFrames = (*env)->GetArrayLength(env, (jshortArray)audioBuffer);
+        audioBufferFrames = (*env)->GetArrayLength(env, (jshortArray) audioBuffer);
     } else {
-        if (!iscapture) {
-            audioBufferPinned = (*env)->GetByteArrayElements(env, (jbyteArray)audioBuffer, &isCopy);
+        if (!isCapture) {
+            audioBufferPinned = (*env)->GetByteArrayElements(env, (jbyteArray) audioBuffer,
+                                                             &isCopy);
         }
-        audioBufferFrames = (*env)->GetArrayLength(env, (jbyteArray)audioBuffer);
+        audioBufferFrames = (*env)->GetArrayLength(env, (jbyteArray) audioBuffer);
     }
 
     if (audioBufferStereo) {
@@ -667,11 +817,15 @@ void Android_JNI_WriteAudioBuffer(void)
     JNIEnv *mAudioEnv = Android_JNI_GetEnv();
 
     if (audioBuffer16Bit) {
-        (*mAudioEnv)->ReleaseShortArrayElements(mAudioEnv, (jshortArray)audioBuffer, (jshort *)audioBufferPinned, JNI_COMMIT);
-        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, mActivityClass, midAudioWriteShortBuffer, (jshortArray)audioBuffer);
+        (*mAudioEnv)->ReleaseShortArrayElements(mAudioEnv, (jshortArray) audioBuffer,
+                                                (jshort*) audioBufferPinned, JNI_COMMIT);
+        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, sdlLibraryHandlerClass,
+                                           midAudioWriteShortBuffer, (jshortArray) audioBuffer);
     } else {
-        (*mAudioEnv)->ReleaseByteArrayElements(mAudioEnv, (jbyteArray)audioBuffer, (jbyte *)audioBufferPinned, JNI_COMMIT);
-        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, mActivityClass, midAudioWriteByteBuffer, (jbyteArray)audioBuffer);
+        (*mAudioEnv)->ReleaseByteArrayElements(mAudioEnv, (jbyteArray) audioBuffer,
+                                               (jbyte*) audioBufferPinned, JNI_COMMIT);
+        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, sdlLibraryHandlerClass,
+                                           midAudioWriteByteBuffer, (jbyteArray) audioBuffer);
     }
 
     /* JNI_COMMIT means the changes are committed to the VM but the buffer remains pinned */
@@ -685,20 +839,22 @@ int Android_JNI_CaptureAudioBuffer(void *buffer, int buflen)
 
     if (captureBuffer16Bit) {
         SDL_assert((*env)->GetArrayLength(env, (jshortArray)captureBuffer) == (buflen / 2));
-        br = (*env)->CallStaticIntMethod(env, mActivityClass, midCaptureReadShortBuffer, (jshortArray)captureBuffer, JNI_TRUE);
+        br = (*env)->CallStaticIntMethod(env, sdlLibraryHandlerClass, midCaptureReadShortBuffer,
+                                         (jshortArray) captureBuffer, JNI_TRUE);
         if (br > 0) {
-            jshort *ptr = (*env)->GetShortArrayElements(env, (jshortArray)captureBuffer, &isCopy);
+            jshort *ptr = (*env)->GetShortArrayElements(env, (jshortArray) captureBuffer, &isCopy);
             br *= 2;
-            SDL_memcpy(buffer, ptr, br);
-            (*env)->ReleaseShortArrayElements(env, (jshortArray)captureBuffer, (jshort *)ptr, JNI_ABORT);
+            SDL_memcpy(buffer, ptr, (size_t) br);
+            (*env)->ReleaseShortArrayElements(env, (jshortArray) captureBuffer, ptr, JNI_ABORT);
         }
     } else {
         SDL_assert((*env)->GetArrayLength(env, (jshortArray)captureBuffer) == buflen);
-        br = (*env)->CallStaticIntMethod(env, mActivityClass, midCaptureReadByteBuffer, (jbyteArray)captureBuffer, JNI_TRUE);
+        br = (*env)->CallStaticIntMethod(env, sdlLibraryHandlerClass, midCaptureReadByteBuffer,
+                                         (jbyteArray) captureBuffer, JNI_TRUE);
         if (br > 0) {
             jbyte *ptr = (*env)->GetByteArrayElements(env, (jbyteArray)captureBuffer, &isCopy);
-            SDL_memcpy(buffer, ptr, br);
-            (*env)->ReleaseByteArrayElements(env, (jbyteArray)captureBuffer, (jbyte *)ptr, JNI_ABORT);
+            SDL_memcpy(buffer, ptr, (size_t) br);
+            (*env)->ReleaseByteArrayElements(env, (jbyteArray) captureBuffer, ptr, JNI_ABORT);
         }
     }
 
@@ -710,33 +866,37 @@ void Android_JNI_FlushCapturedAudio(void)
     JNIEnv *env = Android_JNI_GetEnv();
     #if 0  /* !!! FIXME: this needs API 23, or it'll do blocking reads and never end. */
     if (captureBuffer16Bit) {
-        const jint len = (*env)->GetArrayLength(env, (jshortArray)captureBuffer);
-        while ((*env)->CallStaticIntMethod(env, mActivityClass, midCaptureReadShortBuffer, (jshortArray)captureBuffer, JNI_FALSE) == len) { /* spin */ }
+        const jint len = (*env)->GetArrayLength(env, (jshortArray) captureBuffer);
+        while ((*env)->CallStaticIntMethod(env, sdlLibraryHandlerClass, midCaptureReadShortBuffer,
+                                           (jshortArray) captureBuffer, JNI_FALSE) == len) { /* spin */ }
     } else {
-        const jint len = (*env)->GetArrayLength(env, (jbyteArray)captureBuffer);
-        while ((*env)->CallStaticIntMethod(env, mActivityClass, midCaptureReadByteBuffer, (jbyteArray)captureBuffer, JNI_FALSE) == len) { /* spin */ }
+        const jint len = (*env)->GetArrayLength(env, (jbyteArray) captureBuffer);
+        while ((*env)->CallStaticIntMethod(env, sdlLibraryHandlerClass, midCaptureReadByteBuffer,
+                                           (jbyteArray) captureBuffer, JNI_FALSE) == len) { /* spin */ }
     }
     #else
     if (captureBuffer16Bit) {
-        (*env)->CallStaticIntMethod(env, mActivityClass, midCaptureReadShortBuffer, (jshortArray)captureBuffer, JNI_FALSE);
+        (*env)->CallStaticIntMethod(env, sdlLibraryHandlerClass, midCaptureReadShortBuffer,
+                                    (jshortArray) captureBuffer, JNI_FALSE);
     } else {
-        (*env)->CallStaticIntMethod(env, mActivityClass, midCaptureReadByteBuffer, (jbyteArray)captureBuffer, JNI_FALSE);
+        (*env)->CallStaticIntMethod(env, sdlLibraryHandlerClass, midCaptureReadByteBuffer,
+                                    (jbyteArray) captureBuffer, JNI_FALSE);
     }
     #endif
 }
 
-void Android_JNI_CloseAudioDevice(const int iscapture)
+void Android_JNI_CloseAudioDevice(const int isCapture)
 {
     JNIEnv *env = Android_JNI_GetEnv();
 
-    if (iscapture) {
-        (*env)->CallStaticVoidMethod(env, mActivityClass, midCaptureClose);
+    if (isCapture) {
+        (*env)->CallStaticVoidMethod(env, sdlLibraryHandlerClass, midCaptureClose);
         if (captureBuffer) {
             (*env)->DeleteGlobalRef(env, captureBuffer);
             captureBuffer = NULL;
         }
     } else {
-        (*env)->CallStaticVoidMethod(env, mActivityClass, midAudioClose);
+        (*env)->CallStaticVoidMethod(env, sdlLibraryHandlerClass, midAudioClose);
         if (audioBuffer) {
             (*env)->DeleteGlobalRef(env, audioBuffer);
             audioBuffer = NULL;
@@ -776,7 +936,8 @@ static SDL_bool Android_JNI_ExceptionOccurred(SDL_bool silent)
             exceptionMessage = (jstring)(*mEnv)->CallObjectMethod(mEnv, exception, mid);
 
             if (exceptionMessage != NULL) {
-                const char* exceptionMessageUTF8 = (*mEnv)->GetStringUTFChars(mEnv, exceptionMessage, 0);
+                const char* exceptionMessageUTF8 = (*mEnv)->GetStringUTFChars(
+                        mEnv, exceptionMessage, 0);
                 SDL_SetError("%s: %s", exceptionNameUTF8, exceptionMessageUTF8);
                 (*mEnv)->ReleaseStringUTFChars(mEnv, exceptionMessage, exceptionMessageUTF8);
             } else {
@@ -817,10 +978,10 @@ static int Internal_Android_JNI_FileOpen(SDL_RWops* ctx)
     fileNameJString = (jstring)ctx->hidden.androidio.fileNameRef;
     ctx->hidden.androidio.position = 0;
 
-    /* context = SDLActivity.getContext(); */
-    mid = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
-            "getContext","()Landroid/content/Context;");
-    context = (*mEnv)->CallStaticObjectMethod(mEnv, mActivityClass, mid);
+    /* context = SDLLibraryHandler.getStaticContext(); */
+    mid = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
+            "getStaticContext","()Landroid/content/Context;");
+    context = (*mEnv)->CallStaticObjectMethod(mEnv, sdlLibraryHandlerClass, mid);
 
 
     /* assetManager = context.getAssets(); */
@@ -831,25 +992,29 @@ static int Internal_Android_JNI_FileOpen(SDL_RWops* ctx)
     /* First let's try opening the file to obtain an AssetFileDescriptor.
     * This method reads the files directly from the APKs using standard *nix calls
     */
-    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, assetManager), "openFd", "(Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");
+    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, assetManager), "openFd",
+                               "(Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;");
     inputStream = (*mEnv)->CallObjectMethod(mEnv, assetManager, mid, fileNameJString);
     if (Android_JNI_ExceptionOccurred(SDL_TRUE)) {
         goto fallback;
     }
 
-    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, inputStream), "getStartOffset", "()J");
-    ctx->hidden.androidio.offset = (*mEnv)->CallLongMethod(mEnv, inputStream, mid);
+    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, inputStream),
+                               "getStartOffset", "()J");
+    ctx->hidden.androidio.offset = (long) (*mEnv)->CallLongMethod(mEnv, inputStream, mid);
     if (Android_JNI_ExceptionOccurred(SDL_TRUE)) {
         goto fallback;
     }
 
-    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, inputStream), "getDeclaredLength", "()J");
-    ctx->hidden.androidio.size = (*mEnv)->CallLongMethod(mEnv, inputStream, mid);
+    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, inputStream),
+                               "getDeclaredLength", "()J");
+    ctx->hidden.androidio.size = (long) (*mEnv)->CallLongMethod(mEnv, inputStream, mid);
     if (Android_JNI_ExceptionOccurred(SDL_TRUE)) {
         goto fallback;
     }
 
-    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, inputStream), "getFileDescriptor", "()Ljava/io/FileDescriptor;");
+    mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, inputStream),
+                               "getFileDescriptor", "()Ljava/io/FileDescriptor;");
     fd = (*mEnv)->CallObjectMethod(mEnv, inputStream, mid);
     fdCls = (*mEnv)->GetObjectClass(mEnv, fd);
     descriptor = (*mEnv)->GetFieldID(mEnv, fdCls, "descriptor", "I");
@@ -862,7 +1027,7 @@ static int Internal_Android_JNI_FileOpen(SDL_RWops* ctx)
     if (0) {
 fallback:
         /* Disabled log message because of spam on the Nexus 7 */
-        /* __android_log_print(ANDROID_LOG_DEBUG, "SDL", "Falling back to legacy InputStream method for opening file"); */
+        /* LOGI("Falling back to legacy InputStream method for opening file"); */
 
         /* Try the old method using InputStream */
         ctx->hidden.androidio.assetFileDescriptorRef = NULL;
@@ -870,16 +1035,18 @@ fallback:
         /* inputStream = assetManager.open(<filename>); */
         mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, assetManager),
                 "open", "(Ljava/lang/String;I)Ljava/io/InputStream;");
-        inputStream = (*mEnv)->CallObjectMethod(mEnv, assetManager, mid, fileNameJString, 1 /* ACCESS_RANDOM */);
+        inputStream = (*mEnv)->CallObjectMethod(mEnv, assetManager, mid,
+                                                fileNameJString, 1 /* ACCESS_RANDOM */);
         if (Android_JNI_ExceptionOccurred(SDL_FALSE)) {
             /* Try fallback to APK expansion files */
-            mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, context),
+            mid = (*mEnv)->GetStaticMethodID(mEnv, sdlFragmentClass,
                 "openAPKExpansionInputStream", "(Ljava/lang/String;)Ljava/io/InputStream;");
             if (!mid) {
                 SDL_SetError("No openAPKExpansionInputStream() in Java class");
                 goto failure; /* Java class is missing the required method */
             }
-            inputStream = (*mEnv)->CallObjectMethod(mEnv, context, mid, fileNameJString);
+            inputStream = (*mEnv)->CallStaticObjectMethod(mEnv, sdlFragmentClass,
+                                                          mid, fileNameJString);
 
             /* Exception is checked first because it always needs to be cleared.
              * If no exception occurred then the last SDL error message is kept.
@@ -959,7 +1126,7 @@ int Android_JNI_FileOpen(SDL_RWops* ctx,
     jstring fileNameJString;
 
     if (!LocalReferenceHolder_Init(&refs, mEnv)) {
-        LocalReferenceHolder_Cleanup(&refs);        
+        LocalReferenceHolder_Cleanup(&refs);
         return -1;
     }
 
@@ -987,11 +1154,12 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
 
     if (ctx->hidden.androidio.assetFileDescriptorRef) {
         size_t bytesMax = size * maxnum;
-        size_t result;
-        if (ctx->hidden.androidio.size != -1 /* UNKNOWN_LENGTH */ && ctx->hidden.androidio.position + bytesMax > ctx->hidden.androidio.size) {
-            bytesMax = ctx->hidden.androidio.size - ctx->hidden.androidio.position;
+        ssize_t result;
+        if (ctx->hidden.androidio.size != -1 /* UNKNOWN_LENGTH */ &&
+                ctx->hidden.androidio.position + bytesMax > ctx->hidden.androidio.size) {
+            bytesMax = (size_t) (ctx->hidden.androidio.size - ctx->hidden.androidio.position);
         }
-        result = read(ctx->hidden.androidio.fd, buffer, bytesMax );
+        result = read(ctx->hidden.androidio.fd, buffer, bytesMax);
         if (result > 0) {
             ctx->hidden.androidio.position += result;
             LocalReferenceHolder_Cleanup(&refs);
@@ -1013,7 +1181,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
 
         mEnv = Android_JNI_GetEnv();
         if (!LocalReferenceHolder_Init(&refs, mEnv)) {
-            LocalReferenceHolder_Cleanup(&refs);            
+            LocalReferenceHolder_Cleanup(&refs);
             return 0;
         }
 
@@ -1026,7 +1194,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
             int result = (*mEnv)->CallIntMethod(mEnv, readableByteChannel, readMethod, byteBuffer);
 
             if (Android_JNI_ExceptionOccurred(SDL_FALSE)) {
-                LocalReferenceHolder_Cleanup(&refs);            
+                LocalReferenceHolder_Cleanup(&refs);
                 return 0;
             }
 
@@ -1038,7 +1206,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
             bytesRead += result;
             ctx->hidden.androidio.position += result;
         }
-        LocalReferenceHolder_Cleanup(&refs);                    
+        LocalReferenceHolder_Cleanup(&refs);
         return bytesRead / size;
     }
 }
@@ -1112,12 +1280,18 @@ Sint64 Android_JNI_FileSeek(SDL_RWops* ctx, Sint64 offset, int whence)
         off_t ret;
         switch (whence) {
             case RW_SEEK_SET:
-                if (ctx->hidden.androidio.size != -1 /* UNKNOWN_LENGTH */ && offset > ctx->hidden.androidio.size) offset = ctx->hidden.androidio.size;
+                if (ctx->hidden.androidio.size != -1 /* UNKNOWN_LENGTH */ &&
+                        offset > ctx->hidden.androidio.size) {
+                    offset = ctx->hidden.androidio.size;
+                }
                 offset += ctx->hidden.androidio.offset;
                 break;
             case RW_SEEK_CUR:
                 offset += ctx->hidden.androidio.position;
-                if (ctx->hidden.androidio.size != -1 /* UNKNOWN_LENGTH */ && offset > ctx->hidden.androidio.size) offset = ctx->hidden.androidio.size;
+                if (ctx->hidden.androidio.size != -1 /* UNKNOWN_LENGTH */ &&
+                        offset > ctx->hidden.androidio.size) {
+                    offset = ctx->hidden.androidio.size;
+                }
                 offset += ctx->hidden.androidio.offset;
                 break;
             case RW_SEEK_END:
@@ -1126,7 +1300,6 @@ Sint64 Android_JNI_FileSeek(SDL_RWops* ctx, Sint64 offset, int whence)
             default:
                 return SDL_SetError("Unknown value for 'whence'");
         }
-        whence = SEEK_SET;
 
         ret = lseek(ctx->hidden.androidio.fd, (off_t)offset, SEEK_SET);
         if (ret == -1) return -1;
@@ -1168,7 +1341,7 @@ Sint64 Android_JNI_FileSeek(SDL_RWops* ctx, Sint64 offset, int whence)
                 if (amount > movement) {
                     amount = movement;
                 }
-                result = Android_JNI_FileRead(ctx, buffer, 1, amount);
+                result = Android_JNI_FileRead(ctx, buffer, 1, (size_t) amount);
                 if (result <= 0) {
                     /* Failed to read/skip the required amount, so fail */
                     return -1;
@@ -1213,10 +1386,12 @@ static jobject Android_JNI_GetSystemServiceObject(const char* name)
 
     service = (*env)->NewStringUTF(env, name);
 
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "getContext", "()Landroid/content/Context;");
-    context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                                    "getStaticContext", "()Landroid/content/Context;");
+    context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
-    mid = (*env)->GetMethodID(env, mActivityClass, "getSystemServiceFromUiThread", "(Ljava/lang/String;)Ljava/lang/Object;");
+    mid = (*env)->GetMethodID(env, sdlFragmentClass, "getSystemServiceFromUiThread",
+                              "(Ljava/lang/String;)Ljava/lang/Object;");
     manager = (*env)->CallObjectMethod(env, context, mid, service);
 
     (*env)->DeleteLocalRef(env, service);
@@ -1250,7 +1425,8 @@ int Android_JNI_SetClipboardText(const char* text)
 
     /* Nest the following in a scope to avoid C89 declaration rules triggered by the macro */
     {
-        jmethodID mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, clipboard), "setText", "(Ljava/lang/CharSequence;)V");
+        jmethodID mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, clipboard),
+                                            "setText", "(Ljava/lang/CharSequence;)V");
         jstring string = (*env)->NewStringUTF(env, text);
         (*env)->CallVoidMethod(env, clipboard, mid, string);
         (*env)->DeleteGlobalRef(env, clipboard);
@@ -1268,13 +1444,15 @@ char* Android_JNI_GetClipboardText(void)
 
     /* Nest the following in a scope to avoid C89 declaration rules triggered by the macro */
     {
-        jmethodID mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, clipboard), "getText", "()Ljava/lang/CharSequence;");
+        jmethodID mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, clipboard),
+                                            "getText", "()Ljava/lang/CharSequence;");
         jobject sequence = (*env)->CallObjectMethod(env, clipboard, mid);
         (*env)->DeleteGlobalRef(env, clipboard);
         if (sequence) {
             jstring string;
             const char* utf;
-            mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, sequence), "toString", "()Ljava/lang/String;");
+            mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, sequence),
+                                      "toString", "()Ljava/lang/String;");
             string = (jstring)((*env)->CallObjectMethod(env, sequence, mid));
             utf = (*env)->GetStringUTFChars(env, string, 0);
             if (utf) {
@@ -1287,7 +1465,7 @@ char* Android_JNI_GetClipboardText(void)
             }
         }
     }
-    CLEANUP_CLIPBOARD();    
+    CLEANUP_CLIPBOARD();
 
     return SDL_strdup("");
 }
@@ -1333,8 +1511,9 @@ int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seco
     }
 
 
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "getContext", "()Landroid/content/Context;");
-    context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                                    "getStaticContext", "()Landroid/content/Context;");
+    context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
     action = (*env)->NewStringUTF(env, "android.intent.action.BATTERY_CHANGED");
 
@@ -1345,7 +1524,9 @@ int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seco
 
     (*env)->DeleteLocalRef(env, action);
 
-    mid = (*env)->GetMethodID(env, mActivityClass, "registerReceiver", "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;");
+    mid = (*env)->GetMethodID(env, sdlFragmentClass, "registerReceiver",
+                              "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)"
+                                      "Landroid/content/Intent;");
     intent = (*env)->CallObjectMethod(env, context, mid, NULL, filter);
 
     (*env)->DeleteLocalRef(env, filter);
@@ -1434,8 +1615,10 @@ int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seco
 int Android_JNI_GetTouchDeviceIds(int **ids) {
     JNIEnv *env = Android_JNI_GetEnv();
     jint sources = 4098; /* == InputDevice.SOURCE_TOUCHSCREEN */
-    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "inputGetInputDeviceIds", "(I)[I");
-    jintArray array = (jintArray) (*env)->CallStaticObjectMethod(env, mActivityClass, mid, sources);
+    jmethodID mid = (*env)->GetStaticMethodID(env, sdlFragmentClass,
+                                              "inputGetInputDeviceIds", "(I)[I");
+    jintArray array = (jintArray) (*env)->CallStaticObjectMethod(
+            env, sdlFragmentClass, mid, sources);
     int number = 0;
     *ids = NULL;
     if (array) {
@@ -1459,12 +1642,9 @@ int Android_JNI_GetTouchDeviceIds(int **ids) {
 void Android_JNI_PollInputDevices(void)
 {
     JNIEnv *env = Android_JNI_GetEnv();
-    (*env)->CallStaticVoidMethod(env, mActivityClass, midPollInputDevices);    
+    (*env)->CallStaticVoidMethod(env, sdlFragmentClass, midPollInputDevices);
 }
 
-/* See SDLActivity.java for constants. */
-#define COMMAND_SET_KEEP_SCREEN_ON    5
-
 /* sends message to be handled on the UI event dispatch thread */
 int Android_JNI_SendMessage(int command, int param)
 {
@@ -1474,43 +1654,85 @@ int Android_JNI_SendMessage(int command, int param)
     if (!env) {
         return -1;
     }
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "sendMessage", "(II)Z");
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass, "sendMessage", "(II)Z");
     if (!mid) {
         return -1;
     }
-    success = (*env)->CallStaticBooleanMethod(env, mActivityClass, mid, command, param);
+    success = (*env)->CallStaticBooleanMethod(env, sdlLibraryHandlerClass, mid, command, param);
     return success ? 0 : -1;
 }
 
 void Android_JNI_SuspendScreenSaver(SDL_bool suspend)
 {
-    Android_JNI_SendMessage(COMMAND_SET_KEEP_SCREEN_ON, (suspend == SDL_FALSE) ? 0 : 1);
+    JNIEnv *env = Android_JNI_GetEnv();
+    if (!env) {
+        return;
+    }
+    
+    jmethodID mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                                              "setKeepScreenOn", "(Z)V");
+    if (!mid) {
+        return;
+    }
+    (*env)->CallStaticVoidMethod(env, sdlLibraryHandlerClass, mid,
+                                 (suspend == SDL_FALSE) ? JNI_TRUE : JNI_FALSE);
 }
 
-void Android_JNI_ShowTextInput(SDL_Rect *inputRect)
-{
+void Android_JNI_ShowTextInputOnWindow(SDL_Rect *inputRect, jobject androidWindow) {
     JNIEnv *env = Android_JNI_GetEnv();
-    jmethodID mid;
     if (!env) {
         return;
     }
 
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "showTextInput", "(IIII)Z");
+    jmethodID mid = (*env)->GetMethodID(env, sdlFragmentClass, "showTextInput", "(IIII)Z");
     if (!mid) {
         return;
     }
-    (*env)->CallStaticBooleanMethod(env, mActivityClass, mid,
-                               inputRect->x,
-                               inputRect->y,
-                               inputRect->w,
-                               inputRect->h );
+    (*env)->CallBooleanMethod(env, androidWindow, mid, inputRect->x, inputRect->y,
+                              inputRect->w, inputRect->h);
+}
+
+void Android_JNI_ShowTextInput(SDL_Rect *inputRect)
+{
+    SDL_Window* windowFocus = SDL_GetKeyboardFocus();
+    if (windowFocus == NULL) {
+        return;
+    }
+    jobject androidWindow = GET_ANDROID_WINDOW(windowFocus);
+    if (androidWindow == NULL)
+        return;
+    Android_JNI_ShowTextInputOnWindow(inputRect, androidWindow);
 }
 
 void Android_JNI_HideTextInput(void)
 {
-    /* has to match Activity constant */
-    const int COMMAND_TEXTEDIT_HIDE = 3;
-    Android_JNI_SendMessage(COMMAND_TEXTEDIT_HIDE, 0);
+    JNIEnv *env = Android_JNI_GetEnv();
+    if (!env) {
+        return;
+    }
+    
+    jmethodID mid = (*env)->GetMethodID(env, sdlFragmentClass, "showTextInput", "(IIII)Z"); // TODO: Make mid static
+    if (!mid) {
+        return;
+    }
+    SDL_Window* windowFocus = SDL_GetKeyboardFocus();
+    if (windowFocus == NULL) {
+        return;
+    }
+    jobject androidWindow = GET_ANDROID_WINDOW(windowFocus);
+    if (androidWindow != NULL) {
+        (*env)->CallBooleanMethod(env, androidWindow, mid);
+    }
+    
+}
+
+void Android_SetSeparateMouseAndTouchHint(SDL_bool value)
+{
+    JNIEnv *env = Android_JNI_GetEnv();
+    jfieldID fid = (*env)->GetStaticFieldID(env, sdlLibraryHandlerClass, 
+                                            "separateMouseAndTouch", "Z");
+    (*env)->SetStaticBooleanField(env, sdlLibraryHandlerClass, fid, 
+                                  (jboolean) (value ? JNI_TRUE : JNI_FALSE));
 }
 
 int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
@@ -1533,7 +1755,7 @@ int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *bu
 
     /* convert parameters */
 
-    clazz = (*env)->FindClass(env, "java/lang/String");
+    clazz = (*env)->FindClass(env, "java/lang/String"); // TODO: Extract to static or use GetObjectClass
 
     title = (*env)->NewStringUTF(env, messageboxdata->title);
     message = (*env)->NewStringUTF(env, messageboxdata->message);
@@ -1541,7 +1763,7 @@ int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *bu
     button_flags = (*env)->NewIntArray(env, messageboxdata->numbuttons);
     button_ids = (*env)->NewIntArray(env, messageboxdata->numbuttons);
     button_texts = (*env)->NewObjectArray(env, messageboxdata->numbuttons,
-        clazz, NULL);
+                                          clazz, NULL);
     for (i = 0; i < messageboxdata->numbuttons; ++i) {
         temp = messageboxdata->buttons[i].flags;
         (*env)->SetIntArrayRegion(env, button_flags, i, 1, &temp);
@@ -1569,25 +1791,24 @@ int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *bu
 
     /* call function */
 
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "getContext","()Landroid/content/Context;");
-
-    context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    mid = (*env)->GetStaticMethodID(env, sdlFragmentClass,
+                                    "getContext", "()Landroid/content/Context;");
 
-    clazz = (*env)->GetObjectClass(env, context);
+    context = (*env)->CallStaticObjectMethod(env, sdlFragmentClass, mid);
 
-    mid = (*env)->GetMethodID(env, clazz,
-        "messageboxShowMessageBox", "(ILjava/lang/String;Ljava/lang/String;[I[I[Ljava/lang/String;[I)I");
-    *buttonid = (*env)->CallIntMethod(env, context, mid,
-        messageboxdata->flags,
-        title,
-        message,
-        button_flags,
-        button_ids,
-        button_texts,
-        colors);
+    mid = (*env)->GetStaticMethodID(
+            env, sdlFragmentClass, "showMessageBox",
+            "(ILjava/lang/String;Ljava/lang/String;[I[I[Ljava/lang/String;[I)I");
+    *buttonid = (*env)->CallStaticIntMethod(env, sdlFragmentClass, mid,
+                                      messageboxdata->flags,
+                                      title,
+                                      message,
+                                      button_flags,
+                                      button_ids,
+                                      button_texts,
+                                      colors);
 
     (*env)->DeleteLocalRef(env, context);
-    (*env)->DeleteLocalRef(env, clazz);
 
     /* delete parameters */
 
@@ -1626,10 +1847,10 @@ void *SDL_AndroidGetActivity()
         return NULL;
     }
 
-    /* return SDLActivity.getContext(); */
-    mid = (*env)->GetStaticMethodID(env, mActivityClass,
-            "getContext","()Landroid/content/Context;");
-    return (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    /* return SDLLibraryHandler.getStaticContext(); */
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+            "getStaticContext","()Landroid/content/Context;");
+    return (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 }
 
 const char * SDL_AndroidGetInternalStoragePath()
@@ -1650,10 +1871,10 @@ const char * SDL_AndroidGetInternalStoragePath()
             return NULL;
         }
 
-        /* context = SDLActivity.getContext(); */
-        mid = (*env)->GetStaticMethodID(env, mActivityClass,
-                "getContext","()Landroid/content/Context;");
-        context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+        /* context = SDLLibraryHandler.getStaticContext(); */
+        mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                "getStaticContext","()Landroid/content/Context;");
+        context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
         /* fileObj = context.getFilesDir(); */
         mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, context),
@@ -1702,7 +1923,7 @@ int SDL_AndroidGetExternalStorageState()
     state = (*env)->GetStringUTFChars(env, stateString, NULL);
 
     /* Print an info message so people debugging know the storage state */
-    __android_log_print(ANDROID_LOG_INFO, "SDL", "external storage state: %s", state);
+    LOGI("external storage state: %s", state);
 
     if (SDL_strcmp(state, "mounted") == 0) {
         stateFlags = SDL_ANDROID_EXTERNAL_STORAGE_READ |
@@ -1736,10 +1957,10 @@ const char * SDL_AndroidGetExternalStoragePath()
             return NULL;
         }
 
-        /* context = SDLActivity.getContext(); */
-        mid = (*env)->GetStaticMethodID(env, mActivityClass,
-                "getContext","()Landroid/content/Context;");
-        context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+        /* context = SDLLibraryHandler.getStaticContext(); */
+        mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                "getStaticContext","()Landroid/content/Context;");
+        context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
         /* fileObj = context.getExternalFilesDir(); */
         mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, context),
@@ -1767,7 +1988,7 @@ const char * SDL_AndroidGetExternalStoragePath()
 
 jclass Android_JNI_GetActivityClass(void)
 {
-    return mActivityClass;
+    return sdlFragmentClass;
 }
 
 #endif /* __ANDROID__ */
diff --git SDL2.orig/src/core/android/SDL_android.h SDL2.new/src/core/android/SDL_android.h
--- SDL2.orig/src/core/android/SDL_android.h
+++ SDL2.new/src/core/android/SDL_android.h
@@ -19,6 +19,7 @@
   3. This notice may not be removed or altered from any source distribution.
 */
 #include "../../SDL_internal.h"
+#include "SDL_android_config.h"
 
 /* Set up for C function definitions, even when using C++ */
 #ifdef __cplusplus
@@ -31,21 +32,30 @@ extern "C" {
 #include <android/native_window_jni.h>
 
 #include "SDL_rect.h"
+#include "SDL_video.h"
+
+#include <jni.h>
 
 /* Interface from the SDL library into the Android Java activity */
-extern void Android_JNI_SetActivityTitle(const char *title);
+extern jobject Android_JNI_CreateWindow(SDL_Window*);
+extern void Android_JNI_DestroyWindow(jobject);
+extern ANativeWindow* Android_JNI_GetNativeWindow(jobject android_window);
+extern void Android_JNI_SetWindowTitle(SDL_Window* window, const char *title);
+extern void Android_JNI_SetWindowIcon(SDL_Window* window, SDL_Surface* icon);
+extern void Android_JNI_SetPixelFormat(jobject android_window, int pixelFormat);
 extern SDL_bool Android_JNI_GetAccelerometerValues(float values[3]);
 extern void Android_JNI_ShowTextInput(SDL_Rect *inputRect);
 extern void Android_JNI_HideTextInput(void);
-extern ANativeWindow* Android_JNI_GetNativeWindow(void);
+extern void Android_SetSeparateMouseAndTouchHint(SDL_bool value);
 
 /* Audio support */
-extern int Android_JNI_OpenAudioDevice(int iscapture, int sampleRate, int is16Bit, int channelCount, int desiredBufferFrames);
+extern int Android_JNI_OpenAudioDevice(int isCapture, int sampleRate, SDL_bool is16Bit,
+                                       int channelCount, int desiredBufferFrames);
 extern void* Android_JNI_GetAudioBuffer(void);
 extern void Android_JNI_WriteAudioBuffer(void);
 extern int Android_JNI_CaptureAudioBuffer(void *buffer, int buflen);
 extern void Android_JNI_FlushCapturedAudio(void);
-extern void Android_JNI_CloseAudioDevice(const int iscapture);
+extern void Android_JNI_CloseAudioDevice(const int isCapture);
 
 #include "SDL_rwops.h"
 
@@ -74,7 +84,6 @@ void Android_JNI_SuspendScreenSaver(SDL_bool suspend);
 int Android_JNI_GetTouchDeviceIds(int **ids);
 
 /* Threads */
-#include <jni.h>
 JNIEnv *Android_JNI_GetEnv(void);
 int Android_JNI_SetupThread(void);
 jclass Android_JNI_GetActivityClass(void);
diff --git SDL2.new/src/core/android/SDL_android_config.h SDL2.new/src/core/android/SDL_android_config.h
new file mode 100644
--- /dev/null
+++ SDL2.new/src/core/android/SDL_android_config.h
@@ -0,0 +1,13 @@
+#ifndef _SDL_ANDROID_CONFIG_H
+#define _SDL_ANDROID_CONFIG_H
+
+#ifndef ANDROID_JAVA_PACKAGE_PATH
+#  define ANDROID_JAVA_PACKAGE_PATH org_libsdl_app
+#endif
+
+#define CONCATENATE_NATIVE_FUNCTION_NAME(pkg, name) Java_ ## pkg ## _ ## name
+#define CREATE_NATIVE_FUNCTION_NAME(pkg, name) CONCATENATE_NATIVE_FUNCTION_NAME(pkg, name)
+#define NATIVE_FUNCTION(name) JNICALL CREATE_NATIVE_FUNCTION_NAME(ANDROID_JAVA_PACKAGE_PATH, name)
+
+
+#endif /* _SDL_ANDROID_CONFIG_H */
diff --git SDL2.orig/src/joystick/android/SDL_sysjoystick.c SDL2.new/src/joystick/android/SDL_sysjoystick.c
--- SDL2.orig/src/joystick/android/SDL_sysjoystick.c
+++ SDL2.new/src/joystick/android/SDL_sysjoystick.c
@@ -167,7 +167,6 @@ keycode_to_SDL(int keycode)
             
         default:
             return -1;
-            break;
     }
     
     /* This is here in case future generations, probably with six fingers per hand, 
@@ -186,7 +185,7 @@ Android_OnPadDown(int device_id, int keycode)
     if (button >= 0) {
         item = JoystickByDeviceId(device_id);
         if (item && item->joystick) {
-            SDL_PrivateJoystickButton(item->joystick, button , SDL_PRESSED);
+            SDL_PrivateJoystickButton(item->joystick, (Uint8) button, SDL_PRESSED);
         }
         return 0;
     }
@@ -202,7 +201,7 @@ Android_OnPadUp(int device_id, int keycode)
     if (button >= 0) {
         item = JoystickByDeviceId(device_id);
         if (item && item->joystick) {
-            SDL_PrivateJoystickButton(item->joystick, button, SDL_RELEASED);
+            SDL_PrivateJoystickButton(item->joystick, (Uint8) button, SDL_RELEASED);
         }
         return 0;
     }
@@ -216,7 +215,7 @@ Android_OnJoy(int device_id, int axis, float value)
     /* Android gives joy info normalized as [-1.0, 1.0] or [0.0, 1.0] */
     SDL_joylist_item *item = JoystickByDeviceId(device_id);
     if (item && item->joystick) {
-        SDL_PrivateJoystickAxis(item->joystick, axis, (Sint16) (32767.*value) );
+        SDL_PrivateJoystickAxis(item->joystick, (Uint8) axis, (Sint16) (32767. * value));
     }
     
     return 0;
@@ -234,7 +233,7 @@ Android_OnHat(int device_id, int hat_id, int x, int y)
     if (x >= -1 && x <=1 && y >= -1 && y <= 1) {
         SDL_joylist_item *item = JoystickByDeviceId(device_id);
         if (item && item->joystick) {
-            SDL_PrivateJoystickHat(item->joystick, hat_id, position_map[y+1][x+1] );
+            SDL_PrivateJoystickHat(item->joystick, (Uint8) hat_id, position_map[y + 1][x + 1]);
         }
         return 0;
     }
@@ -244,7 +243,8 @@ Android_OnHat(int device_id, int hat_id, int x, int y)
 
 
 int
-Android_AddJoystick(int device_id, const char *name, SDL_bool is_accelerometer, int nbuttons, int naxes, int nhats, int nballs)
+Android_AddJoystick(int device_id, const char *name, SDL_bool is_accelerometer,
+                    int nbuttons, int naxes, int nhats, int nballs)
 {
     SDL_JoystickGUID guid;
     SDL_joylist_item *item;
@@ -356,7 +356,8 @@ SDL_SYS_JoystickInit(void)
     
     if (SDL_GetHintBoolean(SDL_HINT_ACCELEROMETER_AS_JOYSTICK, SDL_TRUE)) {
         /* Default behavior, accelerometer as joystick */
-        Android_AddJoystick(ANDROID_ACCELEROMETER_DEVICE_ID, ANDROID_ACCELEROMETER_NAME, SDL_TRUE, 0, 3, 0, 0);
+        Android_AddJoystick(ANDROID_ACCELEROMETER_DEVICE_ID, ANDROID_ACCELEROMETER_NAME,
+                            SDL_TRUE, 0, 3, 0, 0);
     }
    
     return (numjoysticks);
@@ -414,6 +415,7 @@ JoystickByDeviceId(int device_id)
     /* Joystick not found, try adding it */
     SDL_SYS_JoystickDetect();
     
+    item = SDL_joylist;
     while (item != NULL) {
         if (item->device_id == device_id) {
             return item;
@@ -469,13 +471,13 @@ SDL_SYS_JoystickOpen(SDL_Joystick * joystick, int device_index)
 /* Function to determine if this joystick is attached to the system right now */
 SDL_bool SDL_SYS_JoystickAttached(SDL_Joystick *joystick)
 {
-    return joystick->hwdata != NULL;
+    return joystick->hwdata != NULL ? SDL_TRUE : SDL_FALSE;
 }
 
 void
 SDL_SYS_JoystickUpdate(SDL_Joystick * joystick)
 {
-    int i;
+    Uint8 i;
     Sint16 value;
     float values[3];
     SDL_joylist_item *item = SDL_joylist;
diff --git SDL2.orig/src/main/android/SDL_android_main.c SDL2.new/src/main/android/SDL_android_main.c
--- SDL2.orig/src/main/android/SDL_android_main.c
+++ SDL2.new/src/main/android/SDL_android_main.c
@@ -12,15 +12,13 @@
                  Functions called by JNI
 *******************************************************************************/
 #include <jni.h>
-
-/* Called before SDL_main() to initialize JNI bindings in SDL library */
-extern void SDL_Android_Init(JNIEnv* env, jclass cls);
+#include "../../core/android/SDL_android.h"
 
 /* This prototype is needed to prevent a warning about the missing prototype for global function below */
-JNIEXPORT int JNICALL Java_org_libsdl_app_SDLActivity_nativeInit(JNIEnv* env, jclass cls, jobject array);
+JNIEXPORT int NATIVE_FUNCTION(SDLMain_nativeInit)(JNIEnv* env, jclass cls, jobject array);
 
 /* Start up the SDL app */
-JNIEXPORT int JNICALL Java_org_libsdl_app_SDLActivity_nativeInit(JNIEnv* env, jclass cls, jobject array)
+JNIEXPORT int NATIVE_FUNCTION(SDLMain_nativeInit)(JNIEnv* env, jclass cls, jobject array)
 {
     int i;
     int argc;
@@ -28,11 +26,6 @@ JNIEXPORT int JNICALL Java_org_libsdl_app_SDLActivity_nativeInit(JNIEnv* env, jc
     int len;
     char** argv;
 
-    /* This interface could expand with ABI negotiation, callbacks, etc. */
-    SDL_Android_Init(env, cls);
-
-    SDL_SetMainReady();
-
     /* Prepare the arguments. */
 
     len = (*env)->GetArrayLength(env, array);
diff --git SDL2.orig/src/video/SDL_egl.c SDL2.new/src/video/SDL_egl.c
--- SDL2.orig/src/video/SDL_egl.c
+++ SDL2.new/src/video/SDL_egl.c
@@ -260,6 +260,7 @@ SDL_EGL_LoadLibrary(_THIS, const char *egl_path, NativeDisplayType native_displa
     LOAD_FUNC(eglDestroySurface);
     LOAD_FUNC(eglMakeCurrent);
     LOAD_FUNC(eglSwapBuffers);
+    LOAD_FUNC(eglSurfaceAttrib);
     LOAD_FUNC(eglSwapInterval);
     LOAD_FUNC(eglWaitNative);
     LOAD_FUNC(eglWaitGL);
@@ -525,8 +526,10 @@ SDL_EGL_MakeCurrent(_THIS, EGLSurface egl_surface, SDL_GLContext context)
      * with a valid context and invalid surface, so we have to check for both here.
      */
     if (!egl_context || !egl_surface) {
+        fprintf(stderr, "eglMakeCurrent NULL, (rgl_surface = %p)\n", egl_surface);
          _this->egl_data->eglMakeCurrent(_this->egl_data->egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
     } else {
+        fprintf(stderr, "eglMakeCurrent %p, (rgl_surface = %p)\n", egl_context, egl_surface);
         if (!_this->egl_data->eglMakeCurrent(_this->egl_data->egl_display,
             egl_surface, egl_surface, egl_context)) {
             return SDL_SetError("Unable to make EGL context current");
@@ -589,6 +592,33 @@ SDL_EGL_DeleteContext(_THIS, SDL_GLContext context)
 }
 
 EGLSurface *
+SDL_EGL_CreateSurfaceWithoutWindow(_THIS)
+{
+    if (SDL_EGL_ChooseConfig(_this) != 0) {
+        return EGL_NO_SURFACE;
+    }
+    
+    EGLSurface *(*eglCreatePbufferSurface)(EGLDisplay, EGLConfig, EGLint*) = SDL_LoadFunction(_this->egl_data->dll_handle, "eglCreatePbufferSurface");
+    
+    EGLint attribute_list[] = {
+            EGL_WIDTH, 1,
+            EGL_HEIGHT, 1,
+            EGL_NONE
+    };
+    
+//    EGLSurface* surface = _this->egl_data->eglCreatePbufferSurface(
+    EGLSurface* surface = eglCreatePbufferSurface(
+            _this->egl_data->egl_display,
+            _this->egl_data->egl_config,
+            attribute_list);
+    if (surface != EGL_NO_SURFACE) {
+        _this->egl_data->eglSurfaceAttrib(_this->egl_data->egl_display, surface,
+                                          EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
+    }
+    return surface;
+}
+
+EGLSurface *
 SDL_EGL_CreateSurface(_THIS, NativeWindowType nw) 
 {
     if (SDL_EGL_ChooseConfig(_this) != 0) {
@@ -602,17 +632,22 @@ SDL_EGL_CreateSurface(_THIS, NativeWindowType nw)
          */
         EGLint format;
         _this->egl_data->eglGetConfigAttrib(_this->egl_data->egl_display,
-                                            _this->egl_data->egl_config, 
+                                            _this->egl_data->egl_config,
                                             EGL_NATIVE_VISUAL_ID, &format);
 
         ANativeWindow_setBuffersGeometry(nw, 0, 0, format);
     }
-#endif    
+#endif
     
-    return _this->egl_data->eglCreateWindowSurface(
-            _this->egl_data->egl_display,
-            _this->egl_data->egl_config,
-            nw, NULL);
+    EGLSurface* surface = _this->egl_data->eglCreateWindowSurface(
+        _this->egl_data->egl_display,
+        _this->egl_data->egl_config,
+        nw, NULL);
+    if (surface != EGL_NO_SURFACE) {
+        _this->egl_data->eglSurfaceAttrib(_this->egl_data->egl_display, surface,
+                                          EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
+    }
+    return surface;
 }
 
 void
diff --git SDL2.orig/src/video/SDL_egl_c.h SDL2.new/src/video/SDL_egl_c.h
--- SDL2.orig/src/video/SDL_egl_c.h
+++ SDL2.new/src/video/SDL_egl_c.h
@@ -65,6 +65,9 @@ typedef struct SDL_EGL_VideoData
                                  EGLSurface read, EGLContext ctx);
     
     EGLBoolean(EGLAPIENTRY *eglSwapBuffers) (EGLDisplay dpy, EGLSurface draw);
+
+    EGLBoolean(EGLAPIENTRY *eglSurfaceAttrib) (EGLDisplay display, EGLSurface surface,
+                                 EGLint attribute, EGLint value);
     
     EGLBoolean(EGLAPIENTRY *eglSwapInterval) (EGLDisplay dpy, EGLint interval);
     
@@ -90,6 +93,7 @@ extern int SDL_EGL_ChooseConfig(_THIS);
 extern int SDL_EGL_SetSwapInterval(_THIS, int interval);
 extern int SDL_EGL_GetSwapInterval(_THIS);
 extern void SDL_EGL_DeleteContext(_THIS, SDL_GLContext context);
+extern EGLSurface *SDL_EGL_CreateSurfaceWithoutWindow(_THIS);
 extern EGLSurface *SDL_EGL_CreateSurface(_THIS, NativeWindowType nw);
 extern void SDL_EGL_DestroySurface(_THIS, EGLSurface egl_surface);
 
diff --git SDL2.orig/src/video/android/SDL_androidevents.c SDL2.new/src/video/android/SDL_androidevents.c
--- SDL2.orig/src/video/android/SDL_androidevents.c
+++ SDL2.new/src/video/android/SDL_androidevents.c
@@ -27,11 +27,15 @@
 
 #include "SDL_androidevents.h"
 #include "SDL_events.h"
-#include "SDL_androidwindow.h"
 
+extern void Android_EGL_context_restore(SDL_Window* window);
+extern void Android_EGL_context_backup(SDL_Window* window);
 
-void android_egl_context_backup();
-void android_egl_context_restore();
+// TODO: Need to find a better solution than global variables here
+int backup_egl_context_window_id = -1;
+int restore_egl_context_window_id = -1;
+SDL_sem* context_restore_lock = NULL;
+SDL_sem* context_backup_lock = NULL;
 
 #if SDL_AUDIO_DRIVER_ANDROID
 void ANDROIDAUDIO_ResumeDevices(void);
@@ -41,30 +45,6 @@ static void ANDROIDAUDIO_ResumeDevices(void) {}
 static void ANDROIDAUDIO_PauseDevices(void) {}
 #endif
 
-void 
-android_egl_context_restore() 
-{
-    SDL_Event event;
-    SDL_WindowData *data = (SDL_WindowData *) Android_Window->driverdata;
-    if (SDL_GL_MakeCurrent(Android_Window, (SDL_GLContext) data->egl_context) < 0) {
-        /* The context is no longer valid, create a new one */
-        data->egl_context = (EGLContext) SDL_GL_CreateContext(Android_Window);
-        SDL_GL_MakeCurrent(Android_Window, (SDL_GLContext) data->egl_context);
-        event.type = SDL_RENDER_DEVICE_RESET;
-        SDL_PushEvent(&event);
-    }
-}
-
-void 
-android_egl_context_backup() 
-{
-    /* Keep a copy of the EGL Context so we can try to restore it when we resume */
-    SDL_WindowData *data = (SDL_WindowData *) Android_Window->driverdata;
-    data->egl_context = SDL_GL_GetCurrentContext();
-    /* We need to do this so the EGLSurface can be freed */
-    SDL_GL_MakeCurrent(Android_Window, NULL);
-}
-
 void
 Android_PumpEvents(_THIS)
 {
@@ -72,17 +52,35 @@ Android_PumpEvents(_THIS)
 #if SDL_ANDROID_BLOCK_ON_PAUSE
     static int isPausing = 0;
 #endif
+    if (context_restore_lock == NULL) context_restore_lock = SDL_CreateSemaphore(0);
+    if (context_backup_lock == NULL) context_backup_lock = SDL_CreateSemaphore(0);
     /* No polling necessary */
+    fprintf(stderr, "Checking for context restore and backup requests\n");
+    int backup_win_id = backup_egl_context_window_id;
+    if (backup_win_id != -1) {
+        if (restore_egl_context_window_id != backup_win_id) {
+            Android_EGL_context_backup(SDL_GetWindowFromID(backup_egl_context_window_id));
+        }
+        backup_egl_context_window_id = -1;
+        SDL_SemPost(context_backup_lock);
+    }
+    if (restore_egl_context_window_id != -1) {
+        if (restore_egl_context_window_id != backup_win_id) {
+            Android_EGL_context_restore(SDL_GetWindowFromID(restore_egl_context_window_id));
+        }
+        restore_egl_context_window_id = -1;
+        fprintf(stderr, "Posting update on context restore lock\n");
+        SDL_SemPost(context_restore_lock);
+    }
 
     /*
-     * Android_ResumeSem and Android_PauseSem are signaled from Java_org_libsdl_app_SDLActivity_nativePause and Java_org_libsdl_app_SDLActivity_nativeResume
+     * Android_ResumeSem and Android_PauseSem are signaled from SDLFragment_nativePause and SDLFragment_nativeResume
      * When the pause semaphore is signaled, if SDL_ANDROID_BLOCK_ON_PAUSE is defined the event loop will block until the resume signal is emitted.
      */
 
 #if SDL_ANDROID_BLOCK_ON_PAUSE
     if (isPaused && !isPausing) {
         /* Make sure this is the last thing we do before pausing */
-        android_egl_context_backup();
         ANDROIDAUDIO_PauseDevices();
         if(SDL_SemWait(Android_ResumeSem) == 0) {
 #else
@@ -91,10 +89,6 @@ Android_PumpEvents(_THIS)
 #endif
             isPaused = 0;
             ANDROIDAUDIO_ResumeDevices();
-            /* Restore the GL Context from here, as this operation is thread dependent */
-            if (!SDL_HasEvent(SDL_QUIT)) {
-                android_egl_context_restore();
-            }
         }
     }
     else {
@@ -102,7 +96,8 @@ Android_PumpEvents(_THIS)
         if( isPausing || SDL_SemTryWait(Android_PauseSem) == 0 ) {
             /* We've been signaled to pause, but before we block ourselves, 
             we need to make sure that certain key events have reached the app */
-            if (SDL_HasEvent(SDL_WINDOWEVENT) || SDL_HasEvent(SDL_APP_WILLENTERBACKGROUND) || SDL_HasEvent(SDL_APP_DIDENTERBACKGROUND) ) {
+            if (SDL_HasEvent(SDL_WINDOWEVENT) || SDL_HasEvent(SDL_APP_WILLENTERBACKGROUND)
+                || SDL_HasEvent(SDL_APP_DIDENTERBACKGROUND)) {
                 isPausing = 1;
             }
             else {
@@ -112,7 +107,6 @@ Android_PumpEvents(_THIS)
         }
 #else
         if(SDL_SemTryWait(Android_PauseSem) == 0) {
-            android_egl_context_backup();
             ANDROIDAUDIO_PauseDevices();
             isPaused = 1;
         }
diff --git SDL2.orig/src/video/android/SDL_androidevents.h SDL2.new/src/video/android/SDL_androidevents.h
--- SDL2.orig/src/video/android/SDL_androidevents.h
+++ SDL2.new/src/video/android/SDL_androidevents.h
@@ -22,6 +22,11 @@
 
 #include "SDL_androidvideo.h"
 
+extern int backup_egl_context_window_id;
+extern int restore_egl_context_window_id;
+extern SDL_sem* context_restore_lock;
+extern SDL_sem* context_backup_lock;
+
 extern void Android_PumpEvents(_THIS);
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git SDL2.orig/src/video/android/SDL_androidgl.c SDL2.new/src/video/android/SDL_androidgl.c
--- SDL2.orig/src/video/android/SDL_androidgl.c
+++ SDL2.new/src/video/android/SDL_androidgl.c
@@ -34,6 +34,7 @@
 #include <android/log.h>
 
 #include <dlfcn.h>
+#include <SDL_events.h>
 
 SDL_EGL_CreateContext_impl(Android)
 SDL_EGL_MakeCurrent_impl(Android)
@@ -56,6 +57,50 @@ Android_GLES_LoadLibrary(_THIS, const char *path) {
     return SDL_EGL_LoadLibrary(_this, path, (NativeDisplayType) 0);
 }
 
+void Android_EGL_trySetContextForWindow(SDL_Window* window, SDL_GLContext context) {
+    SDL_Event event;
+    if (window == NULL) return;
+    if (context == NULL || SDL_GL_MakeCurrent(window, context) < 0) {
+        /* The context is no longer valid, create a new one */
+        if (context != NULL) SDL_EGL_DeleteContext(SDL_GetVideoDevice(), context);
+        context = SDL_GL_CreateContext(window);
+        fprintf(stderr, "Created new context in %s: %p\n", __func__, context);
+        SDL_GL_MakeCurrent(window, context);
+//        event.type = SDL_RENDER_DEVICE_RESET;
+//        SDL_PushEvent(&event);
+    }
+}
+
+void Android_EGL_context_restore(SDL_Window* window) {
+    _THIS = SDL_GetVideoDevice();
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    if (_this->current_glwin != NULL
+        && SDL_GetWindowID(_this->current_glwin) == SDL_GetWindowID(window)) {
+        Android_EGL_trySetContextForWindow(window, data->egl_context);
+    } else if (data->egl_context) {
+        SDL_EGL_DeleteContext(_this, data->egl_context);
+    }
+    data->egl_context = NULL;
+}
+
+void Android_EGL_context_backup(SDL_Window* window) {
+    if (window == NULL) return;
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    _THIS = SDL_GetVideoDevice();
+    data->egl_context = NULL;
+    SDL_bool windowIsCurrent = _this->current_glwin != NULL
+                               && SDL_GetWindowID(_this->current_glwin) == SDL_GetWindowID(window)
+                               ? SDL_TRUE : SDL_FALSE;
+    if (windowIsCurrent) {
+        /* Keep a copy of the EGL Context so we can try to restore it when we resume */
+        data->egl_context = SDL_GL_GetCurrentContext();
+        fprintf(stderr, "Window %d is current context window\n", SDL_GetWindowID(window));
+        /* We need to do this so the EGLSurface can be freed */
+        SDL_GL_MakeCurrent(NULL, NULL);
+        Android_EGL_trySetContextForWindow(window, SDL_GL_CreateContext(window));
+    }
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git SDL2.orig/src/video/android/SDL_androidkeyboard.c SDL2.new/src/video/android/SDL_androidkeyboard.c
--- SDL2.orig/src/video/android/SDL_androidkeyboard.c
+++ SDL2.new/src/video/android/SDL_androidkeyboard.c
@@ -357,7 +357,7 @@ Android_HasScreenKeyboardSupport(_THIS)
 SDL_bool
 Android_IsScreenKeyboardShown(_THIS, SDL_Window * window)
 {
-    return SDL_IsTextInputActive();
+    return SDL_IsTextInputActive(); // TODO: Support multiple windows
 }
 
 void
diff --git SDL2.orig/src/video/android/SDL_androidmessagebox.c SDL2.new/src/video/android/SDL_androidmessagebox.c
--- SDL2.orig/src/video/android/SDL_androidmessagebox.c
+++ SDL2.new/src/video/android/SDL_androidmessagebox.c
@@ -27,7 +27,7 @@
 int
 Android_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
 {
-    int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
+    extern int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
 
     return Android_JNI_ShowMessageBox(messageboxdata, buttonid);
 }
diff --git SDL2.orig/src/video/android/SDL_androidmouse.c SDL2.new/src/video/android/SDL_androidmouse.c
--- SDL2.orig/src/video/android/SDL_androidmouse.c
+++ SDL2.new/src/video/android/SDL_androidmouse.c
@@ -28,8 +28,6 @@
 #include "SDL_events.h"
 #include "../../events/SDL_mouse_c.h"
 
-#include "../../core/android/SDL_android.h"
-
 #define ACTION_DOWN 0
 #define ACTION_UP 1
 #define ACTION_MOVE 2
@@ -49,10 +47,7 @@ Android_InitMouse(void)
     SDLButton = 0;
 }
 
-void Android_OnMouse( int androidButton, int action, float x, float y) {
-    if (!Android_Window) {
-        return;
-    }
+void Android_OnMouse(SDL_Window* window, int androidButton, int action, float x, float y) {
 
     switch(action) {
         case ACTION_DOWN:
@@ -67,24 +62,24 @@ void Android_OnMouse( int androidButton, int action, float x, float y) {
             } else if (androidButton == BUTTON_BACK) {
                 SDLButton = SDL_BUTTON_X2;
             }
-            SDL_SendMouseMotion(Android_Window, 0, 0, x, y);
-            SDL_SendMouseButton(Android_Window, 0, SDL_PRESSED, SDLButton);
+            SDL_SendMouseMotion(window, 0, 0, (int) x, (int) y);
+            SDL_SendMouseButton(window, 0, SDL_PRESSED, SDLButton);
             break;
 
         case ACTION_UP:
             // Android won't give us the button that originated the ACTION_DOWN event, so we'll
             // assume it's the one we stored
-            SDL_SendMouseMotion(Android_Window, 0, 0, x, y);
-            SDL_SendMouseButton(Android_Window, 0, SDL_RELEASED, SDLButton);
+            SDL_SendMouseMotion(window, 0, 0, (int) x, (int) y);
+            SDL_SendMouseButton(window, 0, SDL_RELEASED, SDLButton);
             break;
 
         case ACTION_MOVE:
         case ACTION_HOVER_MOVE:
-            SDL_SendMouseMotion(Android_Window, 0, 0, x, y);
+            SDL_SendMouseMotion(window, 0, 0, (int) x, (int) y);
             break;
 
         case ACTION_SCROLL:
-            SDL_SendMouseWheel(Android_Window, 0, x, y, SDL_MOUSEWHEEL_NORMAL);
+            SDL_SendMouseWheel(window, 0, (int) x, (int) y, SDL_MOUSEWHEEL_NORMAL);
             break;
 
         default:
diff --git SDL2.orig/src/video/android/SDL_androidmouse.h SDL2.new/src/video/android/SDL_androidmouse.h
--- SDL2.orig/src/video/android/SDL_androidmouse.h
+++ SDL2.new/src/video/android/SDL_androidmouse.h
@@ -25,7 +25,7 @@
 #include "SDL_androidvideo.h"
 
 extern void Android_InitMouse(void);
-extern void Android_OnMouse( int button, int action, float x, float y);
+extern void Android_OnMouse(SDL_Window* window, int button, int action, float x, float y);
 
 #endif /* _SDL_androidmouse_h */
 
diff --git SDL2.orig/src/video/android/SDL_androidtouch.c SDL2.new/src/video/android/SDL_androidtouch.c
--- SDL2.orig/src/video/android/SDL_androidtouch.c
+++ SDL2.new/src/video/android/SDL_androidtouch.c
@@ -40,12 +40,12 @@
 #define ACTION_POINTER_DOWN 5
 #define ACTION_POINTER_UP 6
 
-static void Android_GetWindowCoordinates(float x, float y,
+static void Android_GetWindowCoordinates(SDL_Window* window, float x, float y,
                                          int *window_x, int *window_y)
 {
     int window_w, window_h;
 
-    SDL_GetWindowSize(Android_Window, &window_w, &window_h);
+    SDL_GetWindowSize(window, &window_w, &window_h);
     *window_x = (int)(x * window_w);
     *window_y = (int)(y * window_h);
 }
@@ -56,12 +56,9 @@ static void
 SeparateEventsHintWatcher(void *userdata, const char *name,
                           const char *oldValue, const char *newValue)
 {
-    jclass mActivityClass = Android_JNI_GetActivityClass();
-    JNIEnv *env = Android_JNI_GetEnv();
-    jfieldID fid = (*env)->GetStaticFieldID(env, mActivityClass, "mSeparateMouseAndTouch", "Z");
-
-    separate_mouse_and_touch = (newValue && (SDL_strcmp(newValue, "1") == 0));
-    (*env)->SetStaticBooleanField(env, mActivityClass, fid, separate_mouse_and_touch ? JNI_TRUE : JNI_FALSE);
+    separate_mouse_and_touch = (newValue && (SDL_strcmp(newValue, "1") == 0))
+                               ? SDL_TRUE : SDL_FALSE;
+    Android_SetSeparateMouseAndTouchHint(separate_mouse_and_touch);
 }
 
 void Android_InitTouch(void)
@@ -88,17 +85,14 @@ void Android_QuitTouch(void)
     separate_mouse_and_touch = SDL_FALSE;
 }
 
-void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int action, float x, float y, float p)
-{
+
+void Android_OnTouch(SDL_Window* window, int touch_device_id_in, int pointer_finger_id_in,
+                     int action, float x, float y, float p) {
     SDL_TouchID touchDeviceId = 0;
     SDL_FingerID fingerId = 0;
     int window_x, window_y;
     static SDL_FingerID pointerFingerID = 0;
 
-    if (!Android_Window) {
-        return;
-    }
-
     touchDeviceId = (SDL_TouchID)touch_device_id_in;
     if (SDL_AddTouch(touchDeviceId, "") < 0) {
         SDL_Log("error: can't add touch %s, %d", __FILE__, __LINE__);
@@ -109,11 +103,11 @@ void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int actio
         case ACTION_DOWN:
             /* Primary pointer down */
             if (!separate_mouse_and_touch) {
-                Android_GetWindowCoordinates(x, y, &window_x, &window_y);
+                Android_GetWindowCoordinates(window, x, y, &window_x, &window_y);
                 /* send moved event */
-                SDL_SendMouseMotion(Android_Window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
+                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
                 /* send mouse down event */
-                SDL_SendMouseButton(Android_Window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
             }
             pointerFingerID = fingerId;
         case ACTION_POINTER_DOWN:
@@ -124,9 +118,9 @@ void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int actio
         case ACTION_MOVE:
             if (!pointerFingerID) {
                 if (!separate_mouse_and_touch) {
-                    Android_GetWindowCoordinates(x, y, &window_x, &window_y);
+                    Android_GetWindowCoordinates(window, x, y, &window_x, &window_y);
                     /* send moved event */
-                    SDL_SendMouseMotion(Android_Window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
+                    SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
                 }
             }
             SDL_SendTouchMotion(touchDeviceId, fingerId, x, y, p);
@@ -136,7 +130,7 @@ void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int actio
             /* Primary pointer up */
             if (!separate_mouse_and_touch) {
                 /* send mouse up */
-                SDL_SendMouseButton(Android_Window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
+                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
             }
             pointerFingerID = (SDL_FingerID) 0;
         case ACTION_POINTER_UP:
diff --git SDL2.orig/src/video/android/SDL_androidtouch.h SDL2.new/src/video/android/SDL_androidtouch.h
--- SDL2.orig/src/video/android/SDL_androidtouch.h
+++ SDL2.new/src/video/android/SDL_androidtouch.h
@@ -24,6 +24,7 @@
 
 extern void Android_InitTouch(void);
 extern void Android_QuitTouch(void);
-extern void Android_OnTouch( int touch_device_id_in, int pointer_finger_id_in, int action, float x, float y, float p);
+extern void Android_OnTouch(SDL_Window* window, int touch_device_id_in, int pointer_finger_id_in,
+                            int action, float x, float y, float p);
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git SDL2.orig/src/video/android/SDL_androidvideo.c SDL2.new/src/video/android/SDL_androidvideo.c
--- SDL2.orig/src/video/android/SDL_androidvideo.c
+++ SDL2.new/src/video/android/SDL_androidvideo.c
@@ -46,7 +46,6 @@
 static int Android_VideoInit(_THIS);
 static void Android_VideoQuit(_THIS);
 
-#include "../SDL_egl_c.h"
 /* GL functions (SDL_androidgl.c) */
 extern SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window * window);
 extern int Android_GLES_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context);
@@ -58,10 +57,12 @@ extern int Android_GLES_LoadLibrary(_THIS, const char *path);
 #define Android_GLES_GetSwapInterval SDL_EGL_GetSwapInterval
 #define Android_GLES_DeleteContext SDL_EGL_DeleteContext
 
+//extern int Android_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode); // TODO
+
 /* Android driver bootstrap functions */
 
 
-/* These are filled in with real values in Android_SetScreenResolution on init (before SDL_main()) */
+/* These are filled in with real values in SDL_Android_SetScreenDimensions on init (before SDL_main()) */
 int Android_ScreenWidth = 0;
 int Android_ScreenHeight = 0;
 Uint32 Android_ScreenFormat = SDL_PIXELFORMAT_UNKNOWN;
@@ -69,9 +70,6 @@ int Android_ScreenRate = 0;
 
 SDL_sem *Android_PauseSem = NULL, *Android_ResumeSem = NULL;
 
-/* Currently only one window */
-SDL_Window *Android_Window = NULL;
-
 static int
 Android_Available(void)
 {
@@ -91,6 +89,12 @@ Android_DeleteDevice(SDL_VideoDevice * device)
     SDL_free(device);
 }
 
+int Android_SetDisplayMode(_THIS, SDL_VideoDisplay* display, SDL_DisplayMode* mode) {
+//    Android_JNI_SetPixelFormat(jobject android_window, int pixelFormat);
+// TODO: Look into this
+    return 0;
+}
+
 static SDL_VideoDevice *
 Android_CreateDevice(int devindex)
 {
@@ -120,8 +124,13 @@ Android_CreateDevice(int devindex)
 
     device->CreateWindow = Android_CreateWindow;
     device->SetWindowTitle = Android_SetWindowTitle;
+    device->SetWindowIcon = Android_SetWindowIcon;
+    device->SetWindowSize = Android_SetWindowSize;
+    device->SetWindowPosition = Android_SetWindowPosition;
+    device->ShowWindow = Android_ShowWindow;
     device->DestroyWindow = Android_DestroyWindow;
     device->GetWindowWMInfo = Android_GetWindowWMInfo;
+    device->SetDisplayMode = Android_SetDisplayMode;
 
     device->free = Android_DeleteDevice;
 
@@ -167,6 +176,14 @@ Android_VideoInit(_THIS)
 {
     SDL_DisplayMode mode;
 
+    // Check if we are in an app process
+    if (Android_JNI_GetEnv() == NULL) {
+        return -1;
+    }
+    
+    if (!Android_PauseSem) Android_PauseSem = SDL_CreateSemaphore(0);
+    if (!Android_ResumeSem) Android_ResumeSem = SDL_CreateSemaphore(0);
+    
     mode.format = Android_ScreenFormat;
     mode.w = Android_ScreenWidth;
     mode.h = Android_ScreenHeight;
@@ -192,15 +209,18 @@ void
 Android_VideoQuit(_THIS)
 {
     Android_QuitTouch();
+    if (Android_PauseSem) SDL_DestroySemaphore(Android_PauseSem);
+    if (Android_ResumeSem) SDL_DestroySemaphore(Android_ResumeSem);
+    Android_PauseSem = NULL;
+    Android_ResumeSem = NULL;
 }
 
-void
-Android_SetScreenResolution(int width, int height, Uint32 format, float rate)
+/* This function gets called before VideoInit() */
+void SDL_Android_SetScreenDimensions(int width, int height, float rate)
 {
     Android_ScreenWidth = width;
     Android_ScreenHeight = height;
-    Android_ScreenFormat = format;
-    Android_ScreenRate = rate;
+    Android_ScreenRate = (int) rate;
 
     /*
       Update the resolution of the desktop mode, so that the window
@@ -217,19 +237,25 @@ Android_SetScreenResolution(int width, int height, Uint32 format, float rate)
         display->desktop_mode.h = Android_ScreenHeight;
         display->desktop_mode.refresh_rate  = Android_ScreenRate;
     }
+}
 
-    if (Android_Window) {
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_RESIZED, width, height);
-
-        /* Force the current mode to match the resize otherwise the SDL_WINDOWEVENT_RESTORED event
-         * will fall back to the old mode */
-        SDL_VideoDisplay *display = SDL_GetDisplayForWindow(Android_Window);
-
-        display->current_mode.format = format;
-        display->current_mode.w = width;
-        display->current_mode.h = height;
-        display->current_mode.refresh_rate = rate;
-    }
+void
+Android_SetWindowSurfaceResolution(SDL_Window* window, int width, int height, Uint32 format) // TODO: Global format?
+{
+    Android_ScreenFormat = format;
+    ((SDL_WindowData*) window->driverdata)->surface_w = width;
+    ((SDL_WindowData*) window->driverdata)->surface_h = height;
+    fprintf(stderr, "Window %d size changing to %dx%d\n", SDL_GetWindowID(window), width, height);
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, width, height);
+
+    /* Force the current mode to match the resize otherwise the SDL_WINDOWEVENT_RESTORED event
+     * will fall back to the old mode */
+    SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
+
+    display->current_mode.format = format;
+    display->current_mode.w = width;
+    display->current_mode.h = height;
+    display->current_mode.refresh_rate = Android_ScreenRate;
 }
 
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
diff --git SDL2.orig/src/video/android/SDL_androidvideo.h SDL2.new/src/video/android/SDL_androidvideo.h
--- SDL2.orig/src/video/android/SDL_androidvideo.h
+++ SDL2.new/src/video/android/SDL_androidvideo.h
@@ -27,8 +27,9 @@
 #include "SDL_rect.h"
 #include "../SDL_sysvideo.h"
 
-/* Called by the JNI layer when the screen changes size or format */
-extern void Android_SetScreenResolution(int width, int height, Uint32 format, float rate);
+/* Called by the JNI layer when a window surface changes size or format */
+extern void Android_SetWindowSurfaceResolution(SDL_Window* window, int width, int height, Uint32 format);
+extern void SDL_Android_SetScreenDimensions(int width, int height, float rate);
 
 /* Private display data */
 
@@ -41,7 +42,6 @@ extern int Android_ScreenWidth;
 extern int Android_ScreenHeight;
 extern Uint32 Android_ScreenFormat;
 extern SDL_sem *Android_PauseSem, *Android_ResumeSem;
-extern SDL_Window *Android_Window;
 
 
 #endif /* _SDL_androidvideo_h */
diff --git SDL2.orig/src/video/android/SDL_androidwindow.c SDL2.new/src/video/android/SDL_androidwindow.c
--- SDL2.orig/src/video/android/SDL_androidwindow.c
+++ SDL2.new/src/video/android/SDL_androidwindow.c
@@ -34,13 +34,6 @@ int
 Android_CreateWindow(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data;
-    
-    if (Android_Window) {
-        return SDL_SetError("Android only supports one window");
-    }
-    
-    Android_PauseSem = SDL_CreateSemaphore(0);
-    Android_ResumeSem = SDL_CreateSemaphore(0);
 
     /* Adjust the window data to match the screen */
     window->x = 0;
@@ -49,37 +42,35 @@ Android_CreateWindow(_THIS, SDL_Window * window)
     window->h = Android_ScreenHeight;
 
     window->flags &= ~SDL_WINDOW_RESIZABLE;     /* window is NEVER resizeable */
-    window->flags |= SDL_WINDOW_FULLSCREEN;     /* window is always fullscreen */
-    window->flags &= ~SDL_WINDOW_HIDDEN;
-    window->flags |= SDL_WINDOW_SHOWN;          /* only one window on Android */
-    window->flags |= SDL_WINDOW_INPUT_FOCUS;    /* always has input focus */
+    window->flags &= ~SDL_WINDOW_FULLSCREEN;     /* window is !not! always fullscreen (e.g. soft keyboard showing) */
+//    window->flags &= ~SDL_WINDOW_HIDDEN;
+//    window->flags |= SDL_WINDOW_SHOWN;          /* only one window on Android */
+//    window->flags |= SDL_WINDOW_INPUT_FOCUS;    /* always has input focus */
 
-    /* One window, it always has focus */
+    /* One window, it always has focus */ // TODO: Handle this
     SDL_SetMouseFocus(window);
-    SDL_SetKeyboardFocus(window);
+//    SDL_SetKeyboardFocus(window); // TODO: This does nothing here
     
     data = (SDL_WindowData *) SDL_calloc(1, sizeof(*data));
     if (!data) {
         return SDL_OutOfMemory();
     }
+    data->surface_w = Android_ScreenWidth;
+    data->surface_h = Android_ScreenHeight;
+    window->driverdata = data;
     
-    data->native_window = Android_JNI_GetNativeWindow();
+    data->android_window = NULL;
+    data->native_window = NULL;
+    data->egl_surface = SDL_EGL_CreateSurfaceWithoutWindow(_this);
     
-    if (!data->native_window) {
-        SDL_free(data);
-        return SDL_SetError("Could not fetch native window");
-    }
-    
-    data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);
-
     if (data->egl_surface == EGL_NO_SURFACE) {
-        ANativeWindow_release(data->native_window);
+        window->driverdata = NULL;
+        if (data->native_window) ANativeWindow_release(data->native_window);
+        data->native_window = NULL;
         SDL_free(data);
+        fprintf(stderr, "%s\n", SDL_GetError());
         return SDL_SetError("Could not create GLES window surface");
     }
-
-    window->driverdata = data;
-    Android_Window = window;
     
     return 0;
 }
@@ -87,32 +78,85 @@ Android_CreateWindow(_THIS, SDL_Window * window)
 void
 Android_SetWindowTitle(_THIS, SDL_Window * window)
 {
-    Android_JNI_SetActivityTitle(window->title);
+    Android_JNI_SetWindowTitle(window, window->title);
+}
+
+void
+Android_SetWindowIcon(_THIS, SDL_Window* window, SDL_Surface* icon) {
+    Android_JNI_SetWindowIcon(window, icon);
+}
+
+void
+Android_SetWindowSize(_THIS, SDL_Window* window) {
+    SDL_WindowData* data = window->driverdata;
+    if (window->w != data->surface_w || window->h != data->surface_h) {
+        window->w = data->surface_w;
+        window->h = data->surface_h;
+    }
+}
+
+void
+Android_SetWindowPosition(_THIS, SDL_Window *window) {
+    window->x = 0; // TODO: Maybe allow the window manager to actually handle this
+    window->y = 0;
+}
+
+void Android_ShowWindow(_THIS, SDL_Window *window) {
+    SDL_WindowData* data = window->driverdata;
+    data->android_window = Android_JNI_CreateWindow(window);
+    if (data->android_window == NULL) {
+        window->driverdata = NULL;
+        SDL_free(data);
+        SDL_SetError("Failed to create Android window");
+        return;
+    }
+    
+    data->native_window = Android_JNI_GetNativeWindow(data->android_window);
+    
+    if (!data->native_window) {
+        window->driverdata = NULL;
+        SDL_free(data);
+        SDL_SetError("Could not fetch native window");
+        return;
+    }
+    
+    EGLSurface* oldSurface = data->egl_surface;
+    
+    data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);
+    if (data->egl_surface == EGL_NO_SURFACE) {
+        window->driverdata = NULL;
+        if (data->native_window) ANativeWindow_release(data->native_window);
+        data->native_window = NULL;
+        SDL_free(data);
+        fprintf(stderr, "%s\n", SDL_GetError());
+        SDL_SetError("Could not create GLES window surface");
+        return;
+    }
+    
+    if (oldSurface != EGL_NO_SURFACE) {
+        SDL_EGL_DestroySurface(_this, oldSurface);
+    }
+    
+    SDL_SetKeyboardFocus(window); // TODO: This is a workaround, because it can not be in Android_CreateWindow
 }
 
 void
 Android_DestroyWindow(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data;
-    
-    if (window == Android_Window) {
-        Android_Window = NULL;
-        if (Android_PauseSem) SDL_DestroySemaphore(Android_PauseSem);
-        if (Android_ResumeSem) SDL_DestroySemaphore(Android_ResumeSem);
-        Android_PauseSem = NULL;
-        Android_ResumeSem = NULL;
-        
-        if(window->driverdata) {
-            data = (SDL_WindowData *) window->driverdata;
-            if (data->egl_surface != EGL_NO_SURFACE) {
-                SDL_EGL_DestroySurface(_this, data->egl_surface);
-            }
-            if (data->native_window) {
-                ANativeWindow_release(data->native_window);
-            }
-            SDL_free(window->driverdata);
-            window->driverdata = NULL;
+    if(window->driverdata) {
+        data = (SDL_WindowData *) window->driverdata;
+        if (data->egl_surface != EGL_NO_SURFACE) {
+            SDL_EGL_DestroySurface(_this, data->egl_surface);
+        }
+        if (data->native_window) {
+            ANativeWindow_release(data->native_window);
+        }
+        if (data->android_window) {
+            Android_JNI_DestroyWindow(data->android_window);
         }
+        SDL_free(window->driverdata);
+        window->driverdata = NULL;
     }
 }
 
diff --git SDL2.orig/src/video/android/SDL_androidwindow.h SDL2.new/src/video/android/SDL_androidwindow.h
--- SDL2.orig/src/video/android/SDL_androidwindow.h
+++ SDL2.new/src/video/android/SDL_androidwindow.h
@@ -25,9 +25,16 @@
 
 #include "../../core/android/SDL_android.h"
 #include "../SDL_egl_c.h"
+#include "jni.h"
+#define GET_ANDROID_WINDOW(sdlWindow) ((SDL_WindowData*) sdlWindow->driverdata == NULL\
+           ? NULL : ((SDL_WindowData*) sdlWindow->driverdata)->android_window)
 
 extern int Android_CreateWindow(_THIS, SDL_Window * window);
 extern void Android_SetWindowTitle(_THIS, SDL_Window * window);
+extern void Android_SetWindowIcon(_THIS, SDL_Window* window, SDL_Surface* icon);
+extern void Android_SetWindowSize(_THIS, SDL_Window* window);
+extern void Android_SetWindowPosition(_THIS, SDL_Window *window);
+extern void Android_ShowWindow(_THIS, SDL_Window *window);
 extern void Android_DestroyWindow(_THIS, SDL_Window * window);
 extern SDL_bool Android_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo * info);
 
@@ -36,6 +43,9 @@ typedef struct
     EGLSurface egl_surface;
     EGLContext egl_context; /* We use this to preserve the context when losing focus */
     ANativeWindow* native_window;
+    jobject android_window;
+    int surface_w;
+    int surface_h;
     
 } SDL_WindowData;
 
