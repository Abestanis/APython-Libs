--- SDL2.orig/src/core/android/SDL_android.c
+++ SDL2.new/src/core/android/SDL_android.c
@@ -22,7 +22,6 @@
 #include "SDL_stdinc.h"
 #include "SDL_assert.h"
 #include "SDL_hints.h"
-#include "SDL_log.h"
 
 #ifdef __ANDROID__
 
@@ -34,19 +33,18 @@
 #include "../../video/android/SDL_androidkeyboard.h"
 #include "../../video/android/SDL_androidmouse.h"
 #include "../../video/android/SDL_androidtouch.h"
-#include "../../video/android/SDL_androidvideo.h"
+#include "../../video/android/SDL_androidevents.h"
 #include "../../video/android/SDL_androidwindow.h"
 #include "../../joystick/android/SDL_sysjoystick_c.h"
 
 #include <android/log.h>
 #include <pthread.h>
-#include <sys/types.h>
 #include <unistd.h>
 #define LOG_TAG "SDL_android"
-/* #define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__) */
-/* #define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__) */
-#define LOGI(...) do {} while (0)
-#define LOGE(...) do {} while (0)
+#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
+#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
+//#define LOGI(...) do {} while (0)
+//#define LOGE(...) do {} while (0)
 
 /* Uncomment this to log messages entering and exiting methods in this file */
 /* #define DEBUG_JNI */
@@ -56,8 +54,6 @@ static void Android_JNI_ThreadDestroyed(void*);
 /*******************************************************************************
  This file links the Java side of Android with libsdl
 *******************************************************************************/
-#include <jni.h>
-#include <android/log.h>
 
 
 /*******************************************************************************
@@ -66,8 +62,9 @@ static void Android_JNI_ThreadDestroyed(void*);
 static pthread_key_t mThreadKey;
 static JavaVM* mJavaVM;
 
-/* Main activity */
-static jclass mActivityClass;
+/* Main classes to interact with the java side */
+static jclass sdlFragmentClass;
+static jclass sdlLibraryHandlerClass;
 
 /* method signatures */
 static jmethodID midGetNativeSurface;
@@ -76,11 +73,17 @@ static jmethodID midAudioWriteShortBuffer;
 static jmethodID midAudioWriteByteBuffer;
 static jmethodID midAudioQuit;
 static jmethodID midPollInputDevices;
+static jmethodID midCreateWindow;
+static jmethodID midSetPixelFormat;
+static jfieldID  fidNativeWindow;
 
 /* Accelerometer data storage */
 static float fLastAccelerometer[3];
 static SDL_bool bHasNewData;
 
+#define GET_SDL_WINDOW(env, jobject) \
+    (SDL_GetWindowFromID((*env)->GetLongField(env, jobject, fidNativeWindow)))
+
 /*******************************************************************************
                  Functions called by JNI
 *******************************************************************************/
@@ -103,45 +106,57 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)
         __android_log_print(ANDROID_LOG_ERROR, "SDL", "Error initializing pthread key");
     }
     Android_JNI_SetupThread();
-
+    
+    // TODO: Maybe implement some communication via sockets to the process which owns the vm
+    
     return JNI_VERSION_1_4;
 }
 
 /* Called before SDL_main() to initialize JNI bindings */
-JNIEXPORT void JNICALL SDL_Android_Init(JNIEnv* mEnv, jclass cls)
+JNIEXPORT void JNICALL SDL_Android_Init(JNIEnv* mEnv, jclass fragmentClass, jclass libHandlerClass)
 {
     __android_log_print(ANDROID_LOG_INFO, "SDL", "SDL_Android_Init()");
 
     Android_JNI_SetupThread();
 
-    mActivityClass = (jclass)((*mEnv)->NewGlobalRef(mEnv, cls));
+    sdlFragmentClass       = (jclass)((*mEnv)->NewGlobalRef(mEnv, fragmentClass));
+    sdlLibraryHandlerClass = (jclass)((*mEnv)->NewGlobalRef(mEnv, libHandlerClass));
 
-    midGetNativeSurface = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midGetNativeSurface = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass,
                                 "getNativeSurface","()Landroid/view/Surface;");
-    midAudioInit = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioInit = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass,
                                 "audioInit", "(IZZI)I");
-    midAudioWriteShortBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioWriteShortBuffer = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass,
                                 "audioWriteShortBuffer", "([S)V");
-    midAudioWriteByteBuffer = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioWriteByteBuffer = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass,
                                 "audioWriteByteBuffer", "([B)V");
-    midAudioQuit = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midAudioQuit = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass,
                                 "audioQuit", "()V");
-    midPollInputDevices = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
+    midPollInputDevices = (*mEnv)->GetStaticMethodID(mEnv, sdlFragmentClass,
                                 "pollInputDevices", "()V");
+    midCreateWindow = (*mEnv)->GetStaticMethodID(mEnv, sdlFragmentClass,
+                                "createWindow", "()Ljava/lang/Object;");
+    midSetPixelFormat = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass, "setPixelFormat", "(I)V");
+    fidNativeWindow = (*mEnv)->GetFieldID(mEnv, sdlFragmentClass, "nativeWindowId", "J");
 
     bHasNewData = SDL_FALSE;
 
-    if (!midGetNativeSurface || !midAudioInit ||
-       !midAudioWriteShortBuffer || !midAudioWriteByteBuffer || !midAudioQuit || !midPollInputDevices) {
+    if (!midGetNativeSurface || !midAudioInit || !midAudioWriteShortBuffer ||
+        !midAudioWriteByteBuffer || !midAudioQuit || !midPollInputDevices ||
+        !midSetPixelFormat || !midCreateWindow || !fidNativeWindow) {
         __android_log_print(ANDROID_LOG_WARN, "SDL", "SDL: Couldn't locate Java callbacks, check that they're named and typed correctly");
     }
     __android_log_print(ANDROID_LOG_INFO, "SDL", "SDL_Android_Init() finished!");
 }
 
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeInitLibrary)(
+        JNIEnv *env, jclass cls, jclass activityClass) {
+    SDL_Android_Init(env, activityClass, cls);
+    SDL_SetMainReady();
+}
+
 /* Drop file */
-void Java_org_libsdl_app_SDLActivity_onNativeDropFile(
-                                    JNIEnv* env, jclass jcls,
-                                    jstring filename)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeDropFile)(JNIEnv* env, jclass jcls, jstring filename)
 {
     const char *path = (*env)->GetStringUTFChars(env, filename, NULL);
     SDL_SendDropFile(path);
@@ -149,96 +164,163 @@ void Java_org_libsdl_app_SDLActivity_onNativeDropFile(
 }
 
 /* Resize */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeResize(
-                                    JNIEnv* env, jclass jcls,
-                                    jint width, jint height, jint format, jfloat rate)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeResize)(
+        JNIEnv* env, jobject obj, jint width, jint height, jint format)
 {
-    Android_SetScreenResolution(width, height, format, rate);
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    Android_SetWindowSurfaceResolution(window, width, height, (Uint32) format);
 }
 
-/* Paddown */
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_onNativePadDown(
-                                    JNIEnv* env, jclass jcls,
-                                    jint device_id, jint keycode)
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeDisplayResize)(
+        JNIEnv* env, jclass cls, jint screenWidth, jint screenHeight, jfloat refreshRate)
+{
+    SDL_Android_SetScreenDimensions(screenWidth, screenHeight, refreshRate);
+}
+
+// Paddown
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_onNativePadDown)(
+        JNIEnv* env, jclass jcls, jint device_id, jint keycode)
 {
     return Android_OnPadDown(device_id, keycode);
 }
 
-/* Padup */
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_onNativePadUp(
-                                   JNIEnv* env, jclass jcls,
-                                   jint device_id, jint keycode)
+// Padup
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_onNativePadUp)(
+        JNIEnv* env, jclass jcls, jint device_id, jint keycode)
 {
     return Android_OnPadUp(device_id, keycode);
 }
 
 /* Joy */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeJoy(
-                                    JNIEnv* env, jclass jcls,
-                                    jint device_id, jint axis, jfloat value)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeJoy)(
+        JNIEnv* env, jclass jcls, jint device_id, jint axis, jfloat value)
 {
     Android_OnJoy(device_id, axis, value);
 }
 
 /* POV Hat */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeHat(
-                                    JNIEnv* env, jclass jcls,
-                                    jint device_id, jint hat_id, jint x, jint y)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeHat)(
+        JNIEnv* env, jclass jcls, jint device_id, jint hat_id, jint x, jint y)
 {
     Android_OnHat(device_id, hat_id, x, y);
 }
 
 
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_nativeAddJoystick(
-    JNIEnv* env, jclass jcls,
-    jint device_id, jstring device_name, jint is_accelerometer, 
-    jint nbuttons, jint naxes, jint nhats, jint nballs)
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_nativeAddJoystick)(
+        JNIEnv* env, jclass jcls, jint device_id, jstring device_name, jint is_accelerometer,
+        jint nbuttons, jint naxes, jint nhats, jint nballs)
 {
-    int retval;
     const char *name = (*env)->GetStringUTFChars(env, device_name, NULL);
 
-    retval = Android_AddJoystick(device_id, name, (SDL_bool) is_accelerometer, nbuttons, naxes, nhats, nballs);
+    int result = Android_AddJoystick(device_id, name, (SDL_bool) is_accelerometer, nbuttons, naxes, nhats, nballs);
 
     (*env)->ReleaseStringUTFChars(env, device_name, name);
     
-    return retval;
+    return result;
 }
 
-JNIEXPORT jint JNICALL Java_org_libsdl_app_SDLActivity_nativeRemoveJoystick(
-    JNIEnv* env, jclass jcls, jint device_id)
+JNIEXPORT int NATIVE_FUNCTION(SDLWindowFragment_nativeRemoveJoystick)(JNIEnv* env, jclass jcls, jint device_id)
 {
     return Android_RemoveJoystick(device_id);
 }
 
-
 /* Surface Created */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeSurfaceChanged(JNIEnv* env, jclass jcls)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeSurfaceChanged)(JNIEnv* env, jobject obj)
 {
     SDL_WindowData *data;
     SDL_VideoDevice *_this;
 
-    if (Android_Window == NULL || Android_Window->driverdata == NULL ) {
+    SDL_Window* sdl_window = GET_SDL_WINDOW(env, obj);
+    if (sdl_window == NULL) {
+        //TODO
+        fprintf(stderr, "onNativeSurfaceChanged: Failed to retrieve the SDL window from the Android window!\n");
+        return;
+    } else if (sdl_window->driverdata == NULL ) {
+        fprintf(stderr, "onNativeSurfaceChanged: SDL window is uninitialized!\n");
         return;
     }
     
-    _this =  SDL_GetVideoDevice();
-    data =  (SDL_WindowData *) Android_Window->driverdata;
+    _this = SDL_GetVideoDevice();
+    data = (SDL_WindowData *) sdl_window->driverdata;
     
     /* If the surface has been previously destroyed by onNativeSurfaceDestroyed, recreate it here */
-    if (data->egl_surface == EGL_NO_SURFACE) {
-        if(data->native_window) {
+    if (!data->native_window || data->egl_surface == EGL_NO_SURFACE) {
+        fprintf(stderr, "Creating new surface!\n");
+        SDL_EGL_MakeCurrent(_this, NULL, NULL);
+        SDL_EGL_DestroySurface(_this, data->egl_surface);
+        data->egl_surface = SDL_EGL_CreateSurfaceWithoutWindow(_this);
+        if (data->native_window) {
             ANativeWindow_release(data->native_window);
+            data->native_window = NULL;
         }
-        data->native_window = Android_JNI_GetNativeWindow();
+        data->native_window = Android_JNI_GetNativeWindow(obj);
         data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);
+        fprintf(stderr, "New surface is %p\n", data->egl_surface);
+        SDL_Event event;
+        event.type = SDL_RENDER_TARGETS_RESET;
+        SDL_PushEvent(&event);
     }
-    
-    /* GL Context handling is done in the event loop because this function is run from the Java thread */
-    
+}
+
+
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeHideWindow)(JNIEnv* env, jobject obj) {
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_MINIMIZED, 0, 0);
+}
+
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeRestoreWindow)(JNIEnv* env, jobject obj) {
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESTORED, 0, 0);
+    fprintf(stderr, "Waiting for context restore lock\n");
+    restore_egl_context_window_id = SDL_GetWindowID(window);
+//    SDL_SemWait(context_restore_lock);
+    fprintf(stderr, "Received context restore lock update\n");
+}
+
+JNIEXPORT void Android_JNI_ShowTextInputOnWindow(SDL_Rect *inputRect, jobject androidWindow);
+
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeWindowFocusChanged)(
+        JNIEnv* env, jobject obj, jboolean hasFocus) {
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    fprintf(stderr, "Window %d focus changed: %s\n", SDL_GetWindowID(window),
+            hasFocus == JNI_TRUE ? "SDL_WINDOWEVENT_FOCUS_GAINED" : "SDL_WINDOWEVENT_FOCUS_LOST");
+    SDL_SetKeyboardFocus(hasFocus == JNI_TRUE ? window : NULL);
+//    if (hasFocus) {
+//        SDL_Window* focusWindow = SDL_GetKeyboardFocus();
+//        if (SDL_GetWindowID(focusWindow) == SDL_GetWindowID(window)) {
+//            Android_JNI_ShowTextInputOnWindow(&((SDL_VideoData*) SDL_GetVideoDevice()->driverdata)->textRect, obj);
+//        }
+//    }
+}
+
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_nativeOnWindowClose)(JNIEnv* env, jclass obj)
+{
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_CLOSE, 0, 0);
 }
 
 /* Surface Destroyed */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeSurfaceDestroyed(JNIEnv* env, jclass jcls)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeSurfaceDestroyed)(JNIEnv* env, jobject obj)
 {
     /* We have to clear the current context and destroy the egl surface here
      * Otherwise there's BAD_NATIVE_WINDOW errors coming from eglCreateWindowSurface on resume
@@ -246,41 +328,46 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeSurfaceDestroyed(
      */
     SDL_WindowData *data;
     SDL_VideoDevice *_this;
-    
-    if (Android_Window == NULL || Android_Window->driverdata == NULL ) {
+
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    } else if (window->driverdata == NULL ) {
         return;
     }
-    
+
     _this =  SDL_GetVideoDevice();
-    data = (SDL_WindowData *) Android_Window->driverdata;
+    data = (SDL_WindowData *) window->driverdata;
     
+    fprintf(stderr, "Setting window to backup the egl context of to %d\n", SDL_GetWindowID(window));
+    backup_egl_context_window_id = SDL_GetWindowID(window);
+
     if (data->egl_surface != EGL_NO_SURFACE) {
         SDL_EGL_MakeCurrent(_this, NULL, NULL);
         SDL_EGL_DestroySurface(_this, data->egl_surface);
-        data->egl_surface = EGL_NO_SURFACE;
+        data->egl_surface = SDL_EGL_CreateSurfaceWithoutWindow(_this);
+        if (data->native_window) {
+            ANativeWindow_release(data->native_window);
+            data->native_window = NULL;
+        }
     }
-    
-    /* GL Context handling is done in the event loop because this function is run from the Java thread */
-
 }
 
 /* Keydown */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyDown(
-                                    JNIEnv* env, jclass jcls, jint keycode)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeKeyDown)(JNIEnv* env, jclass jcls, jint keycode)
 {
     Android_OnKeyDown(keycode);
 }
 
 /* Keyup */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyUp(
-                                    JNIEnv* env, jclass jcls, jint keycode)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeKeyUp)(JNIEnv* env, jclass jcls, jint keycode)
 {
     Android_OnKeyUp(keycode);
 }
 
 /* Keyboard Focus Lost */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyboardFocusLost(
-                                    JNIEnv* env, jclass jcls)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeKeyboardFocusLost)(JNIEnv* env, jclass jcls)
 {
     /* Calling SDL_StopTextInput will take care of hiding the keyboard and cleaning up the DummyText widget */
     SDL_StopTextInput();
@@ -288,26 +375,33 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeKeyboardFocusLost
 
 
 /* Touch */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeTouch(
-                                    JNIEnv* env, jclass jcls,
-                                    jint touch_device_id_in, jint pointer_finger_id_in,
-                                    jint action, jfloat x, jfloat y, jfloat p)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeTouch)(
+        JNIEnv* env, jobject obj, jint touch_device_id_in, jint pointer_finger_id_in, jint action,
+        jfloat x, jfloat y, jfloat p)
 {
-    Android_OnTouch(touch_device_id_in, pointer_finger_id_in, action, x, y, p);
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    Android_OnTouch(window, touch_device_id_in, pointer_finger_id_in, action, x, y, p);
 }
 
 /* Mouse */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeMouse(
-                                    JNIEnv* env, jclass jcls,
-                                    jint button, jint action, jfloat x, jfloat y)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeMouse)(
+        JNIEnv* env, jobject obj, jint button, jint action, jfloat x, jfloat y)
 {
-    Android_OnMouse(button, action, x, y);
+    SDL_Window* window = GET_SDL_WINDOW(env, obj);
+    if (window == NULL) {
+        fprintf(stderr, "Window was NULL in %s, %s!\n", __FILE__, __func__);
+        return;
+    }
+    Android_OnMouse(window, button, action, x, y);
 }
 
 /* Accelerometer */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeAccel(
-                                    JNIEnv* env, jclass jcls,
-                                    jfloat x, jfloat y, jfloat z)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_onNativeAccel)(
+        JNIEnv* env, jclass jcls, jfloat x, jfloat y, jfloat z)
 {
     fLastAccelerometer[0] = x;
     fLastAccelerometer[1] = y;
@@ -316,15 +410,13 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_onNativeAccel(
 }
 
 /* Low memory */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeLowMemory(
-                                    JNIEnv* env, jclass cls)
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeLowMemory)(JNIEnv* env, jclass cls)
 {
     SDL_SendAppEvent(SDL_APP_LOWMEMORY);
 }
 
 /* Quit */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeQuit(
-                                    JNIEnv* env, jclass cls)
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeQuit)(JNIEnv* env, jclass cls)
 {
     /* Discard previous events. The user should have handled state storage
      * in SDL_APP_WILLENTERBACKGROUND. After nativeQuit() is called, no
@@ -339,44 +431,32 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeQuit(
 }
 
 /* Pause */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativePause(
-                                    JNIEnv* env, jclass cls)
+void NATIVE_FUNCTION(SDLLibraryHandler_nativePause)(JNIEnv* env, jclass cls)
 {
     __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "nativePause()");
-    if (Android_Window) {
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_FOCUS_LOST, 0, 0);
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_MINIMIZED, 0, 0);
-        SDL_SendAppEvent(SDL_APP_WILLENTERBACKGROUND);
-        SDL_SendAppEvent(SDL_APP_DIDENTERBACKGROUND);
-    
-        /* *After* sending the relevant events, signal the pause semaphore 
-         * so the event loop knows to pause and (optionally) block itself */
-        if (!SDL_SemValue(Android_PauseSem)) SDL_SemPost(Android_PauseSem);
-    }
+    SDL_SendAppEvent(SDL_APP_WILLENTERBACKGROUND);
+    SDL_SendAppEvent(SDL_APP_DIDENTERBACKGROUND);
+
+    /* *After* sending the relevant events, signal the pause semaphore
+     * so the event loop knows to pause and (optionally) block itself */
+    if (!SDL_SemValue(Android_PauseSem)) SDL_SemPost(Android_PauseSem);
 }
 
 /* Resume */
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLActivity_nativeResume(
-                                    JNIEnv* env, jclass cls)
+JNIEXPORT void NATIVE_FUNCTION(SDLLibraryHandler_nativeResume)(JNIEnv* env, jclass cls)
 {
     __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "nativeResume()");
-
-    if (Android_Window) {
-        SDL_SendAppEvent(SDL_APP_WILLENTERFOREGROUND);
-        SDL_SendAppEvent(SDL_APP_DIDENTERFOREGROUND);
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_FOCUS_GAINED, 0, 0);
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_RESTORED, 0, 0);
-        /* Signal the resume semaphore so the event loop knows to resume and restore the GL Context
-         * We can't restore the GL Context here because it needs to be done on the SDL main thread
-         * and this function will be called from the Java thread instead.
-         */
-        if (!SDL_SemValue(Android_ResumeSem)) SDL_SemPost(Android_ResumeSem);
-    }
+    SDL_SendAppEvent(SDL_APP_WILLENTERFOREGROUND);
+    SDL_SendAppEvent(SDL_APP_DIDENTERFOREGROUND);
+    /* Signal the resume semaphore so the event loop knows to resume and restore the GL Context
+     * We can't restore the GL Context here because it needs to be done on the SDL main thread
+     * and this function will be called from the Java thread instead.
+     */
+    if (!SDL_SemValue(Android_ResumeSem)) SDL_SemPost(Android_ResumeSem);
 }
 
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeCommitText(
-                                    JNIEnv* env, jclass cls,
-                                    jstring text, jint newCursorPosition)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_nativeCommitText)(
+        JNIEnv* env, jobject obj, jstring text, jint newCursorPosition)
 {
     const char *utftext = (*env)->GetStringUTFChars(env, text, NULL);
 
@@ -385,9 +465,8 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeCommitText(
     (*env)->ReleaseStringUTFChars(env, text, utftext);
 }
 
-JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeSetComposingText(
-                                    JNIEnv* env, jclass cls,
-                                    jstring text, jint newCursorPosition)
+JNIEXPORT void NATIVE_FUNCTION(SDLWindowFragment_nativeSetComposingText)(
+        JNIEnv* env, jobject obj, jstring text, jint newCursorPosition)
 {
     const char *utftext = (*env)->GetStringUTFChars(env, text, NULL);
 
@@ -396,7 +475,8 @@ JNIEXPORT void JNICALL Java_org_libsdl_app_SDLInputConnection_nativeSetComposing
     (*env)->ReleaseStringUTFChars(env, text, utftext);
 }
 
-JNIEXPORT jstring JNICALL Java_org_libsdl_app_SDLActivity_nativeGetHint(JNIEnv* env, jclass cls, jstring name) {
+JNIEXPORT jstring JNICALL NATIVE_FUNCTION(SDLWindowFragment_nativeGetHint)(
+        JNIEnv* env, jobject obj, jstring name) {
     const char *utfname = (*env)->GetStringUTFChars(env, name, NULL);
     const char *hint = SDL_GetHint(utfname);
 
@@ -457,31 +537,75 @@ static SDL_bool LocalReferenceHolder_IsActive(void)
     return s_active > 0;
 }
 
-ANativeWindow* Android_JNI_GetNativeWindow(void)
+jobject Android_JNI_CreateWindow(SDL_Window* sdl_window) {
+    JNIEnv *env = Android_JNI_GetEnv();
+    jobject android_window = (*env)->CallStaticObjectMethod(env, sdlFragmentClass, midCreateWindow);
+    android_window = (*env)->NewGlobalRef(env, android_window);
+    if (android_window != NULL) {
+        fprintf(stderr, "Setting window Id on android window");
+        (*env)->SetLongField(env, android_window, fidNativeWindow, SDL_GetWindowID(sdl_window));
+    }
+    return android_window;
+}
+
+void Android_JNI_DestroyWindow(jobject android_window) {
+    JNIEnv *env = Android_JNI_GetEnv();
+    jmethodID midDestroyWindow = (*env)->GetMethodID(env, sdlFragmentClass, "destroy", "()V");
+    (*env)->CallVoidMethod(env, android_window, midDestroyWindow);
+    (*env)->DeleteGlobalRef(env, android_window);
+}
+
+ANativeWindow* Android_JNI_GetNativeWindow(jobject android_window)
 {
     ANativeWindow* anw;
     jobject s;
     JNIEnv *env = Android_JNI_GetEnv();
 
-    s = (*env)->CallStaticObjectMethod(env, mActivityClass, midGetNativeSurface);
+    s = (*env)->CallObjectMethod(env, android_window, midGetNativeSurface);
     anw = ANativeWindow_fromSurface(env, s);
     (*env)->DeleteLocalRef(env, s);
-  
+
     return anw;
 }
 
-void Android_JNI_SetActivityTitle(const char *title)
+void Android_JNI_SetWindowTitle(SDL_Window* window, const char *title)
 {
     jmethodID mid;
+    if (GET_ANDROID_WINDOW(window) == NULL) return;
     JNIEnv *mEnv = Android_JNI_GetEnv();
-    mid = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,"setActivityTitle","(Ljava/lang/String;)Z");
+    mid = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass, "setWindowTitle", "(Ljava/lang/String;)Z");
     if (mid) {
         jstring jtitle = (jstring)((*mEnv)->NewStringUTF(mEnv, title));
-        (*mEnv)->CallStaticBooleanMethod(mEnv, mActivityClass, mid, jtitle);
+        (*mEnv)->CallBooleanMethod(mEnv, GET_ANDROID_WINDOW(window), mid, jtitle);
         (*mEnv)->DeleteLocalRef(mEnv, jtitle);
     }
 }
 
+void Android_JNI_SetWindowIcon(SDL_Window* window, SDL_Surface* icon)
+{
+    jmethodID mid;
+    if (GET_ANDROID_WINDOW(window) == NULL) return;
+    JNIEnv *mEnv = Android_JNI_GetEnv();
+    mid = (*mEnv)->GetMethodID(mEnv, sdlFragmentClass, "setWindowIcon", "([III)V");
+    if (mid) {
+        if (icon != NULL) {
+            SDL_assert(icon->format->format == SDL_PIXELFORMAT_ARGB8888); // TODO: Convert if wrong
+            int size = icon->w * icon->h;
+            jintArray iconData = (*mEnv)->NewIntArray(mEnv, size);
+            (*mEnv)->SetIntArrayRegion(mEnv, iconData, 0, size, icon->pixels);
+            (*mEnv)->CallVoidMethod(mEnv, GET_ANDROID_WINDOW(window), mid, iconData, icon->w, icon->h);
+            (*mEnv)->DeleteLocalRef(mEnv, iconData);
+        } else {
+            (*mEnv)->CallVoidMethod(mEnv, GET_ANDROID_WINDOW(window), mid, NULL, -1, -1);
+        }
+    }
+}
+
+void Android_JNI_SetPixelFormat(jobject android_window, int pixelFormat) {
+    JNIEnv *mEnv = Android_JNI_GetEnv();
+    (*mEnv)->CallVoidMethod(mEnv, android_window, midSetPixelFormat);
+}
+
 SDL_bool Android_JNI_GetAccelerometerValues(float values[3])
 {
     int i;
@@ -521,12 +645,17 @@ JNIEnv* Android_JNI_GetEnv(void)
      * is a no-op.
      * Note: You can call this function any number of times for the same thread, there's no harm in it
      */
+     if (mJavaVM == NULL) {
+         LOGE("The current process is not attached to any JVM!");
+         fprintf(stderr, "ERROR: The current process is not attached to any JVM!\n");
+         return NULL;
+     }
 
     JNIEnv *env;
     int status = (*mJavaVM)->AttachCurrentThread(mJavaVM, &env, NULL);
     if(status < 0) {
         LOGE("failed to attach current thread");
-        return 0;
+        return NULL;
     }
 
     /* From http://developer.android.com/guide/practices/jni.html
@@ -569,10 +698,10 @@ int Android_JNI_OpenAudioDevice(int sampleRate, int is16Bit, int channelCount, i
     Android_JNI_SetupThread();
 
     __android_log_print(ANDROID_LOG_VERBOSE, "SDL", "SDL audio: opening device");
-    audioBuffer16Bit = is16Bit;
-    audioBufferStereo = channelCount > 1;
+    audioBuffer16Bit = (jboolean) is16Bit;
+    audioBufferStereo = (jboolean) (channelCount > 1);
 
-    if ((*env)->CallStaticIntMethod(env, mActivityClass, midAudioInit, sampleRate, audioBuffer16Bit, audioBufferStereo, desiredBufferFrames) != 0) {
+    if ((*env)->CallStaticIntMethod(env, sdlFragmentClass, midAudioInit, sampleRate, audioBuffer16Bit, audioBufferStereo, desiredBufferFrames) != 0) {
         /* Error during audio initialization */
         __android_log_print(ANDROID_LOG_WARN, "SDL", "SDL audio: error on AudioTrack initialization!");
         return 0;
@@ -627,10 +756,10 @@ void Android_JNI_WriteAudioBuffer(void)
 
     if (audioBuffer16Bit) {
         (*mAudioEnv)->ReleaseShortArrayElements(mAudioEnv, (jshortArray)audioBuffer, (jshort *)audioBufferPinned, JNI_COMMIT);
-        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, mActivityClass, midAudioWriteShortBuffer, (jshortArray)audioBuffer);
+        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, sdlFragmentClass, midAudioWriteShortBuffer, (jshortArray)audioBuffer);
     } else {
         (*mAudioEnv)->ReleaseByteArrayElements(mAudioEnv, (jbyteArray)audioBuffer, (jbyte *)audioBufferPinned, JNI_COMMIT);
-        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, mActivityClass, midAudioWriteByteBuffer, (jbyteArray)audioBuffer);
+        (*mAudioEnv)->CallStaticVoidMethod(mAudioEnv, sdlFragmentClass, midAudioWriteByteBuffer, (jbyteArray)audioBuffer);
     }
 
     /* JNI_COMMIT means the changes are committed to the VM but the buffer remains pinned */
@@ -640,7 +769,7 @@ void Android_JNI_CloseAudioDevice(void)
 {
     JNIEnv *env = Android_JNI_GetEnv();
 
-    (*env)->CallStaticVoidMethod(env, mActivityClass, midAudioQuit);
+    (*env)->CallStaticVoidMethod(env, sdlFragmentClass, midAudioQuit);
 
     if (audioBuffer) {
         (*env)->DeleteGlobalRef(env, audioBuffer);
@@ -713,13 +842,17 @@ static int Internal_Android_JNI_FileOpen(SDL_RWops* ctx)
         goto failure;
     }
 
+    const char* name = (*mEnv)->GetStringUTFChars(mEnv, (jstring)ctx->hidden.androidio.fileNameRef, 0);
+    fprintf(stderr, "Called %s for file '%s'\n", __func__, name);
+    (*mEnv)->ReleaseStringUTFChars(mEnv, (jstring)ctx->hidden.androidio.fileNameRef, name);
+
     fileNameJString = (jstring)ctx->hidden.androidio.fileNameRef;
     ctx->hidden.androidio.position = 0;
 
-    /* context = SDLActivity.getContext(); */
-    mid = (*mEnv)->GetStaticMethodID(mEnv, mActivityClass,
-            "getContext","()Landroid/content/Context;");
-    context = (*mEnv)->CallStaticObjectMethod(mEnv, mActivityClass, mid);
+    /* context = SDLLibraryHandler.getStaticContext(); */
+    mid = (*mEnv)->GetStaticMethodID(mEnv, sdlLibraryHandlerClass,
+            "getStaticContext","()Landroid/content/Context;");
+    context = (*mEnv)->CallStaticObjectMethod(mEnv, sdlLibraryHandlerClass, mid);
 
 
     /* assetManager = context.getAssets(); */
@@ -760,8 +893,6 @@ static int Internal_Android_JNI_FileOpen(SDL_RWops* ctx)
 
     if (0) {
 fallback:
-        /* Disabled log message because of spam on the Nexus 7 */
-        /* __android_log_print(ANDROID_LOG_DEBUG, "SDL", "Falling back to legacy InputStream method for opening file"); */
 
         /* Try the old method using InputStream */
         ctx->hidden.androidio.assetFileDescriptorRef = NULL;
@@ -772,13 +903,13 @@ fallback:
         inputStream = (*mEnv)->CallObjectMethod(mEnv, assetManager, mid, fileNameJString, 1 /* ACCESS_RANDOM */);
         if (Android_JNI_ExceptionOccurred(SDL_FALSE)) {
             /* Try fallback to APK expansion files */
-            mid = (*mEnv)->GetMethodID(mEnv, (*mEnv)->GetObjectClass(mEnv, context),
+            mid = (*mEnv)->GetStaticMethodID(mEnv, sdlFragmentClass,
                 "openAPKExpansionInputStream", "(Ljava/lang/String;)Ljava/io/InputStream;");
             if (!mid) {
                 SDL_SetError("No openAPKExpansionInputStream() in Java class");
                 goto failure; /* Java class is missing the required method */
             }
-            inputStream = (*mEnv)->CallObjectMethod(mEnv, context, mid, fileNameJString);
+            inputStream = (*mEnv)->CallStaticObjectMethod(mEnv, sdlFragmentClass, mid, fileNameJString);
 
             /* Exception is checked first because it always needs to be cleared.
              * If no exception occurred then the last SDL error message is kept.
@@ -857,7 +988,7 @@ int Android_JNI_FileOpen(SDL_RWops* ctx,
     int retval;
 
     if (!LocalReferenceHolder_Init(&refs, mEnv)) {
-        LocalReferenceHolder_Cleanup(&refs);        
+        LocalReferenceHolder_Cleanup(&refs);
         return -1;
     }
 
@@ -906,7 +1037,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
 
         JNIEnv *mEnv = Android_JNI_GetEnv();
         if (!LocalReferenceHolder_Init(&refs, mEnv)) {
-            LocalReferenceHolder_Cleanup(&refs);            
+            LocalReferenceHolder_Cleanup(&refs);
             return 0;
         }
 
@@ -919,7 +1050,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
             int result = (*mEnv)->CallIntMethod(mEnv, readableByteChannel, readMethod, byteBuffer);
 
             if (Android_JNI_ExceptionOccurred(SDL_FALSE)) {
-                LocalReferenceHolder_Cleanup(&refs);            
+                LocalReferenceHolder_Cleanup(&refs);
                 return 0;
             }
 
@@ -931,7 +1062,7 @@ size_t Android_JNI_FileRead(SDL_RWops* ctx, void* buffer,
             bytesRead += result;
             ctx->hidden.androidio.position += result;
         }
-        LocalReferenceHolder_Cleanup(&refs);                    
+        LocalReferenceHolder_Cleanup(&refs);
         return bytesRead / size;
     }
 }
@@ -1101,10 +1232,10 @@ static jobject Android_JNI_GetSystemServiceObject(const char* name)
 
     jmethodID mid;
 
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "getContext", "()Landroid/content/Context;");
-    jobject context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass, "getStaticContext", "()Landroid/content/Context;");
+    jobject context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
-    mid = (*env)->GetMethodID(env, mActivityClass, "getSystemServiceFromUiThread", "(Ljava/lang/String;)Ljava/lang/Object;");
+    mid = (*env)->GetMethodID(env, sdlFragmentClass, "getSystemServiceFromUiThread", "(Ljava/lang/String;)Ljava/lang/Object;");
     jobject manager = (*env)->CallObjectMethod(env, context, mid, service);
 
     (*env)->DeleteLocalRef(env, service);
@@ -1166,7 +1297,7 @@ char* Android_JNI_GetClipboardText(void)
         }
     }
 
-    CLEANUP_CLIPBOARD();    
+    CLEANUP_CLIPBOARD();
 
     return SDL_strdup("");
 }
@@ -1200,8 +1331,8 @@ int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seco
 
     jmethodID mid;
 
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "getContext", "()Landroid/content/Context;");
-    jobject context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass, "getStaticContext", "()Landroid/content/Context;");
+    jobject context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
     jstring action = (*env)->NewStringUTF(env, "android.intent.action.BATTERY_CHANGED");
 
@@ -1212,7 +1343,7 @@ int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seco
 
     (*env)->DeleteLocalRef(env, action);
 
-    mid = (*env)->GetMethodID(env, mActivityClass, "registerReceiver", "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;");
+    mid = (*env)->GetMethodID(env, sdlFragmentClass, "registerReceiver", "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;");
     jobject intent = (*env)->CallObjectMethod(env, context, mid, NULL, filter);
 
     (*env)->DeleteLocalRef(env, filter);
@@ -1285,8 +1416,8 @@ int Android_JNI_GetPowerInfo(int* plugged, int* charged, int* battery, int* seco
 int Android_JNI_GetTouchDeviceIds(int **ids) {
     JNIEnv *env = Android_JNI_GetEnv();
     jint sources = 4098; /* == InputDevice.SOURCE_TOUCHSCREEN */
-    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "inputGetInputDeviceIds", "(I)[I");
-    jintArray array = (jintArray) (*env)->CallStaticObjectMethod(env, mActivityClass, mid, sources);
+    jmethodID mid = (*env)->GetStaticMethodID(env, sdlFragmentClass, "inputGetInputDeviceIds", "(I)[I");
+    jintArray array = (jintArray) (*env)->CallStaticObjectMethod(env, sdlFragmentClass, mid, sources);
     int number = 0;
     *ids = NULL;
     if (array) {
@@ -1310,12 +1441,9 @@ int Android_JNI_GetTouchDeviceIds(int **ids) {
 void Android_JNI_PollInputDevices(void)
 {
     JNIEnv *env = Android_JNI_GetEnv();
-    (*env)->CallStaticVoidMethod(env, mActivityClass, midPollInputDevices);    
+    (*env)->CallStaticVoidMethod(env, sdlFragmentClass, midPollInputDevices);
 }
 
-/* See SDLActivity.java for constants. */
-#define COMMAND_SET_KEEP_SCREEN_ON    5
-
 /* sends message to be handled on the UI event dispatch thread */
 int Android_JNI_SendMessage(int command, int param)
 {
@@ -1323,42 +1451,81 @@ int Android_JNI_SendMessage(int command, int param)
     if (!env) {
         return -1;
     }
-    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "sendMessage", "(II)Z");
+    jmethodID mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass, "sendMessage", "(II)Z");
     if (!mid) {
         return -1;
     }
-    jboolean success = (*env)->CallStaticBooleanMethod(env, mActivityClass, mid, command, param);
+    jboolean success = (*env)->CallStaticBooleanMethod(env, sdlLibraryHandlerClass, mid, command, param);
     return success ? 0 : -1;
 }
 
 void Android_JNI_SuspendScreenSaver(SDL_bool suspend)
 {
-    Android_JNI_SendMessage(COMMAND_SET_KEEP_SCREEN_ON, (suspend == SDL_FALSE) ? 0 : 1);
+    JNIEnv *env = Android_JNI_GetEnv();
+    if (!env) {
+        return;
+    }
+    
+    jmethodID mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass, "setKeepScreenOn", "(Z)V");
+    if (!mid) {
+        return;
+    }
+    (*env)->CallStaticVoidMethod(env, sdlLibraryHandlerClass, mid, suspend ? JNI_TRUE : JNI_FALSE);
 }
 
-void Android_JNI_ShowTextInput(SDL_Rect *inputRect)
-{
+void Android_JNI_ShowTextInputOnWindow(SDL_Rect *inputRect, jobject androidWindow) {
     JNIEnv *env = Android_JNI_GetEnv();
     if (!env) {
         return;
     }
 
-    jmethodID mid = (*env)->GetStaticMethodID(env, mActivityClass, "showTextInput", "(IIII)Z");
+    jmethodID mid = (*env)->GetMethodID(env, sdlFragmentClass, "showTextInput", "(IIII)Z");
     if (!mid) {
         return;
     }
-    (*env)->CallStaticBooleanMethod(env, mActivityClass, mid,
-                               inputRect->x,
-                               inputRect->y,
-                               inputRect->w,
-                               inputRect->h );
+    (*env)->CallBooleanMethod(env, androidWindow, mid, inputRect->x, inputRect->y,
+                              inputRect->w, inputRect->h);
+}
+
+void Android_JNI_ShowTextInput(SDL_Rect *inputRect)
+{
+    SDL_Window* windowFocus = SDL_GetKeyboardFocus();
+    if (windowFocus == NULL) {
+        return;
+    }
+    jobject androidWindow = GET_ANDROID_WINDOW(windowFocus);
+    if (androidWindow == NULL)
+        return;
+    Android_JNI_ShowTextInputOnWindow(inputRect, androidWindow);
 }
 
 void Android_JNI_HideTextInput(void)
 {
-    /* has to match Activity constant */
-    const int COMMAND_TEXTEDIT_HIDE = 3;
-    Android_JNI_SendMessage(COMMAND_TEXTEDIT_HIDE, 0);
+    JNIEnv *env = Android_JNI_GetEnv();
+    if (!env) {
+        return;
+    }
+    
+    jmethodID mid = (*env)->GetMethodID(env, sdlFragmentClass, "showTextInput", "(IIII)Z"); // TODO: Make mid static
+    if (!mid) {
+        return;
+    }
+    SDL_Window* windowFocus = SDL_GetKeyboardFocus();
+    if (windowFocus == NULL) {
+        return;
+    }
+    jobject androidWindow = GET_ANDROID_WINDOW(windowFocus);
+    if (androidWindow != NULL) {
+        (*env)->CallBooleanMethod(env, androidWindow, mid);
+    }
+    
+}
+
+void Android_SetSeparateMouseAndTouchHint(SDL_bool value)
+{
+    JNIEnv *env = Android_JNI_GetEnv();
+    jfieldID fid = (*env)->GetStaticFieldID(env, sdlLibraryHandlerClass, "separateMouseAndTouch", "Z");
+    (*env)->SetStaticBooleanField(env, sdlLibraryHandlerClass, fid, (jboolean) (value ? JNI_TRUE : JNI_FALSE));
 }
 
 int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
@@ -1376,20 +1543,20 @@ int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *bu
     jobject text;
     jint temp;
     int i;
-
+    
     env = Android_JNI_GetEnv();
-
+    
     /* convert parameters */
-
-    clazz = (*env)->FindClass(env, "java/lang/String");
-
+    
+    clazz = (*env)->FindClass(env, "java/lang/String"); // TODO: Extract to static or use GetObjectClass
+    
     title = (*env)->NewStringUTF(env, messageboxdata->title);
     message = (*env)->NewStringUTF(env, messageboxdata->message);
-
+    
     button_flags = (*env)->NewIntArray(env, messageboxdata->numbuttons);
     button_ids = (*env)->NewIntArray(env, messageboxdata->numbuttons);
     button_texts = (*env)->NewObjectArray(env, messageboxdata->numbuttons,
-        clazz, NULL);
+                                          clazz, NULL);
     for (i = 0; i < messageboxdata->numbuttons; ++i) {
         temp = messageboxdata->buttons[i].flags;
         (*env)->SetIntArrayRegion(env, button_flags, i, 1, &temp);
@@ -1399,7 +1566,7 @@ int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *bu
         (*env)->SetObjectArrayElement(env, button_texts, i, text);
         (*env)->DeleteLocalRef(env, text);
     }
-
+    
     if (messageboxdata->colorScheme) {
         colors = (*env)->NewIntArray(env, SDL_MESSAGEBOX_COLOR_MAX);
         for (i = 0; i < SDL_MESSAGEBOX_COLOR_MAX; ++i) {
@@ -1412,40 +1579,37 @@ int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *bu
     } else {
         colors = NULL;
     }
-
+    
     (*env)->DeleteLocalRef(env, clazz);
-
+    
     /* call function */
-
-    mid = (*env)->GetStaticMethodID(env, mActivityClass, "getContext","()Landroid/content/Context;");
-
-    context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
-
-    clazz = (*env)->GetObjectClass(env, context);
-
-    mid = (*env)->GetMethodID(env, clazz,
-        "messageboxShowMessageBox", "(ILjava/lang/String;Ljava/lang/String;[I[I[Ljava/lang/String;[I)I");
-    *buttonid = (*env)->CallIntMethod(env, context, mid,
-        messageboxdata->flags,
-        title,
-        message,
-        button_flags,
-        button_ids,
-        button_texts,
-        colors);
-
+    
+    mid = (*env)->GetStaticMethodID(env, sdlFragmentClass, "getContext","()Landroid/content/Context;");
+    
+    context = (*env)->CallStaticObjectMethod(env, sdlFragmentClass, mid);
+    
+    mid = (*env)->GetStaticMethodID(env, sdlFragmentClass,
+                              "showMessageBox", "(ILjava/lang/String;Ljava/lang/String;[I[I[Ljava/lang/String;[I)I");
+    *buttonid = (*env)->CallStaticIntMethod(env, sdlFragmentClass, mid,
+                                      messageboxdata->flags,
+                                      title,
+                                      message,
+                                      button_flags,
+                                      button_ids,
+                                      button_texts,
+                                      colors);
+    
     (*env)->DeleteLocalRef(env, context);
-    (*env)->DeleteLocalRef(env, clazz);
-
+    
     /* delete parameters */
-
+    
     (*env)->DeleteLocalRef(env, title);
     (*env)->DeleteLocalRef(env, message);
     (*env)->DeleteLocalRef(env, button_flags);
     (*env)->DeleteLocalRef(env, button_ids);
     (*env)->DeleteLocalRef(env, button_texts);
     (*env)->DeleteLocalRef(env, colors);
-
+    
     return 0;
 }
 
@@ -1461,8 +1625,6 @@ void *SDL_AndroidGetJNIEnv()
     return Android_JNI_GetEnv();
 }
 
-
-
 void *SDL_AndroidGetActivity()
 {
     /* See SDL_system.h for caveats on using this function. */
@@ -1474,10 +1636,10 @@ void *SDL_AndroidGetActivity()
         return NULL;
     }
 
-    /* return SDLActivity.getContext(); */
-    mid = (*env)->GetStaticMethodID(env, mActivityClass,
-            "getContext","()Landroid/content/Context;");
-    return (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+    /* return SDLLibraryHandler.getStaticContext(); */
+    mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+            "getStaticContext","()Landroid/content/Context;");
+    return (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 }
 
 const char * SDL_AndroidGetInternalStoragePath()
@@ -1498,10 +1660,10 @@ const char * SDL_AndroidGetInternalStoragePath()
             return NULL;
         }
 
-        /* context = SDLActivity.getContext(); */
-        mid = (*env)->GetStaticMethodID(env, mActivityClass,
-                "getContext","()Landroid/content/Context;");
-        context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+        /* context = SDLLibraryHandler.getStaticContext(); */
+        mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                "getStaticContext","()Landroid/content/Context;");
+        context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
         /* fileObj = context.getFilesDir(); */
         mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, context),
@@ -1584,10 +1746,10 @@ const char * SDL_AndroidGetExternalStoragePath()
             return NULL;
         }
 
-        /* context = SDLActivity.getContext(); */
-        mid = (*env)->GetStaticMethodID(env, mActivityClass,
-                "getContext","()Landroid/content/Context;");
-        context = (*env)->CallStaticObjectMethod(env, mActivityClass, mid);
+        /* context = SDLLibraryHandler.getStaticContext(); */
+        mid = (*env)->GetStaticMethodID(env, sdlLibraryHandlerClass,
+                "getStaticContext","()Landroid/content/Context;");
+        context = (*env)->CallStaticObjectMethod(env, sdlLibraryHandlerClass, mid);
 
         /* fileObj = context.getExternalFilesDir(); */
         mid = (*env)->GetMethodID(env, (*env)->GetObjectClass(env, context),
@@ -1615,7 +1777,7 @@ const char * SDL_AndroidGetExternalStoragePath()
 
 jclass Android_JNI_GetActivityClass(void)
 {
-    return mActivityClass;
+    return sdlFragmentClass;
 }
 
 #endif /* __ANDROID__ */
--- SDL2.orig/src/core/android/SDL_android.h
+++ SDL2.new/src/core/android/SDL_android.h
@@ -19,6 +19,7 @@
   3. This notice may not be removed or altered from any source distribution.
 */
 #include "../../SDL_internal.h"
+#include "SDL_android_config.h"
 
 /* Set up for C function definitions, even when using C++ */
 #ifdef __cplusplus
@@ -31,13 +32,22 @@ extern "C" {
 #include <android/native_window_jni.h>
 
 #include "SDL_rect.h"
+#include "SDL_video.h"
+
+#include <jni.h>
+#include "SDL_messagebox.h"
 
 /* Interface from the SDL library into the Android Java activity */
-extern void Android_JNI_SetActivityTitle(const char *title);
+extern jobject Android_JNI_CreateWindow(SDL_Window*);
+extern void Android_JNI_DestroyWindow(jobject);
+extern ANativeWindow* Android_JNI_GetNativeWindow(jobject android_window);
+extern void Android_JNI_SetWindowTitle(SDL_Window* window, const char *title);
+extern void Android_JNI_SetWindowIcon(SDL_Window* window, SDL_Surface* icon);
+extern void Android_JNI_SetPixelFormat(jobject android_window, int pixelFormat);
 extern SDL_bool Android_JNI_GetAccelerometerValues(float values[3]);
 extern void Android_JNI_ShowTextInput(SDL_Rect *inputRect);
 extern void Android_JNI_HideTextInput(void);
-extern ANativeWindow* Android_JNI_GetNativeWindow(void);
+extern void Android_SetSeparateMouseAndTouchHint(SDL_bool value);
 
 /* Audio support */
 extern int Android_JNI_OpenAudioDevice(int sampleRate, int is16Bit, int channelCount, int desiredBufferFrames);
@@ -72,11 +82,13 @@ void Android_JNI_SuspendScreenSaver(SDL_bool suspend);
 int Android_JNI_GetTouchDeviceIds(int **ids);
 
 /* Threads */
-#include <jni.h>
 JNIEnv *Android_JNI_GetEnv(void);
 int Android_JNI_SetupThread(void);
 jclass Android_JNI_GetActivityClass(void);
 
+/* MessageBox */
+int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
+
 /* Generic messages */
 int Android_JNI_SendMessage(int command, int param);
 
--- /dev/null
+++ SDL2.new/src/core/android/SDL_android_config.h
@@ -0,0 +1,13 @@
+#ifndef _SDL_ANDROID_CONFIG_H
+#define _SDL_ANDROID_CONFIG_H
+
+#ifndef ANDROID_JAVA_PACKAGE_PATH
+#  define ANDROID_JAVA_PACKAGE_PATH org_libsdl_app
+#endif
+
+#define CONCATENATE_NATIVE_FUNCTION_NAME(pkg, name) Java_ ## pkg ## _ ## name
+#define CREATE_NATIVE_FUNCTION_NAME(pkg, name) CONCATENATE_NATIVE_FUNCTION_NAME(pkg, name)
+#define NATIVE_FUNCTION(name) JNICALL CREATE_NATIVE_FUNCTION_NAME(ANDROID_JAVA_PACKAGE_PATH, name)
+
+
+#endif /* _SDL_ANDROID_CONFIG_H */
--- SDL2.orig/src/main/android/SDL_android_main.c
+++ SDL2.new/src/main/android/SDL_android_main.c
@@ -12,22 +12,18 @@
                  Functions called by JNI
 *******************************************************************************/
 #include <jni.h>
+#include "../../core/android/SDL_android.h"
 
 /* Called before SDL_main() to initialize JNI bindings in SDL library */
 extern void SDL_Android_Init(JNIEnv* env, jclass cls);
 
 /* Start up the SDL app */
-JNIEXPORT int JNICALL Java_org_libsdl_app_SDLActivity_nativeInit(JNIEnv* env, jclass cls, jobject array)
+JNIEXPORT int NATIVE_FUNCTION(SDLMain_nativeInit)(JNIEnv* env, jclass cls, jobject array)
 {
     int i;
     int argc;
     int status;
 
-    /* This interface could expand with ABI negotiation, callbacks, etc. */
-    SDL_Android_Init(env, cls);
-
-    SDL_SetMainReady();
-
     /* Prepare the arguments. */
 
     int len = (*env)->GetArrayLength(env, array);
--- SDL2.orig/src/video/SDL_egl.c
+++ SDL2.new/src/video/SDL_egl.c
@@ -260,6 +260,7 @@ SDL_EGL_LoadLibrary(_THIS, const char *egl_path, NativeDisplayType native_displa
     LOAD_FUNC(eglDestroySurface);
     LOAD_FUNC(eglMakeCurrent);
     LOAD_FUNC(eglSwapBuffers);
+    LOAD_FUNC(eglSurfaceAttrib);
     LOAD_FUNC(eglSwapInterval);
     LOAD_FUNC(eglWaitNative);
     LOAD_FUNC(eglWaitGL);
@@ -588,6 +591,33 @@ SDL_EGL_DeleteContext(_THIS, SDL_GLContext context)
 }
 
 EGLSurface *
+SDL_EGL_CreateSurfaceWithoutWindow(_THIS)
+{
+    if (SDL_EGL_ChooseConfig(_this) != 0) {
+        return EGL_NO_SURFACE;
+    }
+    
+    EGLSurface *(*eglCreatePbufferSurface)(EGLDisplay, EGLConfig, EGLint*) = SDL_LoadFunction(_this->egl_data->dll_handle, "eglCreatePbufferSurface");
+    
+    EGLint attribute_list[] = {
+            EGL_WIDTH, 1,
+            EGL_HEIGHT, 1,
+            EGL_NONE
+    };
+    
+//    EGLSurface* surface = _this->egl_data->eglCreatePbufferSurface(
+    EGLSurface* surface = eglCreatePbufferSurface(
+            _this->egl_data->egl_display,
+            _this->egl_data->egl_config,
+            attribute_list);
+    if (surface != EGL_NO_SURFACE) {
+        _this->egl_data->eglSurfaceAttrib(_this->egl_data->egl_display, surface,
+                                          EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
+    }
+    return surface;
+}
+
+EGLSurface *
 SDL_EGL_CreateSurface(_THIS, NativeWindowType nw) 
 {
     if (SDL_EGL_ChooseConfig(_this) != 0) {
@@ -601,17 +631,22 @@ SDL_EGL_CreateSurface(_THIS, NativeWindowType nw)
          */
         EGLint format;
         _this->egl_data->eglGetConfigAttrib(_this->egl_data->egl_display,
-                                            _this->egl_data->egl_config, 
+                                            _this->egl_data->egl_config,
                                             EGL_NATIVE_VISUAL_ID, &format);
 
         ANativeWindow_setBuffersGeometry(nw, 0, 0, format);
     }
-#endif    
+#endif
     
-    return _this->egl_data->eglCreateWindowSurface(
-            _this->egl_data->egl_display,
-            _this->egl_data->egl_config,
-            nw, NULL);
+    EGLSurface* surface = _this->egl_data->eglCreateWindowSurface(
+        _this->egl_data->egl_display,
+        _this->egl_data->egl_config,
+        nw, NULL);
+    if (surface != EGL_NO_SURFACE) {
+        _this->egl_data->eglSurfaceAttrib(_this->egl_data->egl_display, surface,
+                                          EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED);
+    }
+    return surface;
 }
 
 void
--- SDL2.orig/src/video/SDL_egl_c.h
+++ SDL2.new/src/video/SDL_egl_c.h
@@ -65,6 +65,9 @@ typedef struct SDL_EGL_VideoData
                                  EGLSurface read, EGLContext ctx);
     
     EGLBoolean(EGLAPIENTRY *eglSwapBuffers) (EGLDisplay dpy, EGLSurface draw);
+
+    EGLBoolean(EGLAPIENTRY *eglSurfaceAttrib) (EGLDisplay display, EGLSurface surface,
+                                 EGLint attribute, EGLint value);
     
     EGLBoolean(EGLAPIENTRY *eglSwapInterval) (EGLDisplay dpy, EGLint interval);
     
@@ -90,6 +93,7 @@ extern int SDL_EGL_ChooseConfig(_THIS);
 extern int SDL_EGL_SetSwapInterval(_THIS, int interval);
 extern int SDL_EGL_GetSwapInterval(_THIS);
 extern void SDL_EGL_DeleteContext(_THIS, SDL_GLContext context);
+extern EGLSurface *SDL_EGL_CreateSurfaceWithoutWindow(_THIS);
 extern EGLSurface *SDL_EGL_CreateSurface(_THIS, NativeWindowType nw);
 extern void SDL_EGL_DestroySurface(_THIS, EGLSurface egl_surface);
 
--- SDL2.orig/src/video/android/SDL_androidevents.c
+++ SDL2.new/src/video/android/SDL_androidevents.c
@@ -29,9 +29,12 @@
 #include "SDL_events.h"
 #include "SDL_androidwindow.h"
 
+extern void Android_EGL_context_restore(SDL_Window* window);
+extern void Android_EGL_context_backup(SDL_Window* window);
 
-void android_egl_context_backup();
-void android_egl_context_restore();
+int backup_egl_context_window_id = -1;
+int restore_egl_context_window_id = -1;
+SDL_sem* context_restore_lock = NULL;
 
 #if SDL_AUDIO_DRIVER_ANDROID
 void AndroidAUD_ResumeDevices(void);
@@ -41,30 +44,6 @@ static void AndroidAUD_ResumeDevices(void) {}
 static void AndroidAUD_PauseDevices(void) {}
 #endif
 
-void 
-android_egl_context_restore() 
-{
-    SDL_Event event;
-    SDL_WindowData *data = (SDL_WindowData *) Android_Window->driverdata;
-    if (SDL_GL_MakeCurrent(Android_Window, (SDL_GLContext) data->egl_context) < 0) {
-        /* The context is no longer valid, create a new one */
-        data->egl_context = (EGLContext) SDL_GL_CreateContext(Android_Window);
-        SDL_GL_MakeCurrent(Android_Window, (SDL_GLContext) data->egl_context);
-        event.type = SDL_RENDER_DEVICE_RESET;
-        SDL_PushEvent(&event);
-    }
-}
-
-void 
-android_egl_context_backup() 
-{
-    /* Keep a copy of the EGL Context so we can try to restore it when we resume */
-    SDL_WindowData *data = (SDL_WindowData *) Android_Window->driverdata;
-    data->egl_context = SDL_GL_GetCurrentContext();
-    /* We need to do this so the EGLSurface can be freed */
-    SDL_GL_MakeCurrent(Android_Window, NULL);
-}
-
 void
 Android_PumpEvents(_THIS)
 {
@@ -72,17 +51,28 @@ Android_PumpEvents(_THIS)
 #if SDL_ANDROID_BLOCK_ON_PAUSE
     static int isPausing = 0;
 #endif
+    if (context_restore_lock == NULL) context_restore_lock = SDL_CreateSemaphore(0);
     /* No polling necessary */
+    fprintf(stderr, "Checking for context restore and backup requests\n");
+    if (backup_egl_context_window_id != -1) {
+        Android_EGL_context_backup(SDL_GetWindowFromID(backup_egl_context_window_id));
+        backup_egl_context_window_id = -1;
+    }
+    if (restore_egl_context_window_id != -1) {
+        Android_EGL_context_restore(SDL_GetWindowFromID(restore_egl_context_window_id));
+        restore_egl_context_window_id = -1;
+        fprintf(stderr, "Posting update on context restore lock\n");
+        SDL_SemPost(context_restore_lock);
+    }
 
     /*
-     * Android_ResumeSem and Android_PauseSem are signaled from Java_org_libsdl_app_SDLActivity_nativePause and Java_org_libsdl_app_SDLActivity_nativeResume
+     * Android_ResumeSem and Android_PauseSem are signaled from SDLFragment_nativePause and SDLFragment_nativeResume
      * When the pause semaphore is signaled, if SDL_ANDROID_BLOCK_ON_PAUSE is defined the event loop will block until the resume signal is emitted.
      */
 
 #if SDL_ANDROID_BLOCK_ON_PAUSE
     if (isPaused && !isPausing) {
         /* Make sure this is the last thing we do before pausing */
-        android_egl_context_backup();
         AndroidAUD_PauseDevices();
         if(SDL_SemWait(Android_ResumeSem) == 0) {
 #else
@@ -91,10 +81,6 @@ Android_PumpEvents(_THIS)
 #endif
             isPaused = 0;
             AndroidAUD_ResumeDevices();
-            /* Restore the GL Context from here, as this operation is thread dependent */
-            if (!SDL_HasEvent(SDL_QUIT)) {
-                android_egl_context_restore();
-            }
         }
     }
     else {
@@ -112,7 +98,6 @@ Android_PumpEvents(_THIS)
         }
 #else
         if(SDL_SemTryWait(Android_PauseSem) == 0) {
-            android_egl_context_backup();
             AndroidAUD_PauseDevices();
             isPaused = 1;
         }
--- SDL2.orig/src/video/android/SDL_androidevents.h
+++ SDL2.new/src/video/android/SDL_androidevents.h
@@ -22,6 +22,10 @@
 
 #include "SDL_androidvideo.h"
 
+extern int backup_egl_context_window_id;
+extern int restore_egl_context_window_id;
+extern SDL_sem* context_restore_lock;
+
 extern void Android_PumpEvents(_THIS);
 
 /* vi: set ts=4 sw=4 expandtab: */
--- SDL2.orig/src/video/android/SDL_androidgl.c
+++ SDL2.new/src/video/android/SDL_androidgl.c
@@ -34,6 +34,7 @@
 #include <android/log.h>
 
 #include <dlfcn.h>
+#include <SDL_events.h>
 
 SDL_EGL_CreateContext_impl(Android)
 SDL_EGL_MakeCurrent_impl(Android)
@@ -53,9 +54,43 @@ Android_GLES_SwapWindow(_THIS, SDL_Window * window)
 
 int
 Android_GLES_LoadLibrary(_THIS, const char *path) {
+//    if (path == NULL) {
+//        return SDL_EGL_LoadLibrary(_this, "libEGL.so", (NativeDisplayType) 0);
+//    }
     return SDL_EGL_LoadLibrary(_this, path, (NativeDisplayType) 0);
 }
 
+void Android_EGL_trySetContextForWindow(SDL_Window* window) {
+    if (window == NULL) return;
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    if (!data->egl_context || SDL_GL_MakeCurrent(window, (SDL_GLContext) data->egl_context) < 0) {
+        /* The context is no longer valid, create a new one */
+        if (data->egl_context) SDL_EGL_DeleteContext(SDL_GetVideoDevice(), data->egl_context);
+        data->egl_context = (EGLContext) SDL_GL_CreateContext(window);
+        SDL_GL_MakeCurrent(window, (SDL_GLContext) data->egl_context);
+        SDL_Event event;
+        event.type = SDL_RENDER_DEVICE_RESET;
+        SDL_PushEvent(&event);
+    }
+}
+
+void Android_EGL_context_restore(SDL_Window* window) {
+    Android_EGL_trySetContextForWindow(window);
+}
+
+void Android_EGL_context_backup(SDL_Window* window) {
+    if (window == NULL) return;
+    /* Keep a copy of the EGL Context so we can try to restore it when we resume */
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+//    data->egl_context = SDL_GL_GetCurrentContext();
+    SDL_GL_MakeCurrent(NULL, NULL);
+    /* We need to do this so the EGLSurface can be freed */
+    /* Change the current context to the pbuffer context */ // TODO: Determine if the current context is from this window
+//    data->egl_surface = SDL_EGL_CreateSurfaceWithoutWindow(SDL_GetVideoDevice());
+    Android_EGL_trySetContextForWindow(window);
+//    SDL_GL_MakeCurrent(window, NULL);
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
--- SDL2.orig/src/video/android/SDL_androidmessagebox.c
+++ SDL2.new/src/video/android/SDL_androidmessagebox.c
@@ -22,13 +22,11 @@
 
 #if SDL_VIDEO_DRIVER_ANDROID
 
-#include "SDL_messagebox.h"
+#include "../../core/android/SDL_android.h"
 
 int
 Android_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
 {
-    int Android_JNI_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
-
     return Android_JNI_ShowMessageBox(messageboxdata, buttonid);
 }
 
--- SDL2.orig/src/video/android/SDL_androidmouse.c
+++ SDL2.new/src/video/android/SDL_androidmouse.c
@@ -38,13 +38,9 @@
 #define BUTTON_SECONDARY 2
 #define BUTTON_TERTIARY 4
 
-void Android_OnMouse( int androidButton, int action, float x, float y) {
+void Android_OnMouse(SDL_Window* window, int androidButton, int action, float x, float y) {
     static Uint8 SDLButton;
 
-    if (!Android_Window) {
-        return;
-    }
-
     switch(action) {
         case ACTION_DOWN:
             // Determine which button originated the event, and store it for ACTION_UP
@@ -54,23 +50,23 @@ void Android_OnMouse( int androidButton, int action, float x, float y) {
             } else if (androidButton == BUTTON_TERTIARY) {
                 SDLButton = SDL_BUTTON_MIDDLE;
             }
-            SDL_SendMouseMotion(Android_Window, 0, 0, x, y);
-            SDL_SendMouseButton(Android_Window, 0, SDL_PRESSED, SDLButton);
+            SDL_SendMouseMotion(window, 0, 0, x, y);
+            SDL_SendMouseButton(window, 0, SDL_PRESSED, SDLButton);
             break;
 
         case ACTION_UP:
             // Android won't give us the button that originated the ACTION_DOWN event, so we'll
             // assume it's the one we stored
-            SDL_SendMouseMotion(Android_Window, 0, 0, x, y);
-            SDL_SendMouseButton(Android_Window, 0, SDL_RELEASED, SDLButton);
+            SDL_SendMouseMotion(window, 0, 0, x, y);
+            SDL_SendMouseButton(window, 0, SDL_RELEASED, SDLButton);
             break;
 
         case ACTION_HOVER_MOVE:
-            SDL_SendMouseMotion(Android_Window, 0, 0, x, y);
+            SDL_SendMouseMotion(window, 0, 0, x, y);
             break;
 
         case ACTION_SCROLL:
-            SDL_SendMouseWheel(Android_Window, 0, x, y, SDL_MOUSEWHEEL_NORMAL);
+            SDL_SendMouseWheel(window, 0, x, y, SDL_MOUSEWHEEL_NORMAL);
             break;
 
         default:
--- SDL2.orig/src/video/android/SDL_androidmouse.h
+++ SDL2.new/src/video/android/SDL_androidmouse.h
@@ -24,7 +24,7 @@
 
 #include "SDL_androidvideo.h"
 
-extern void Android_OnMouse( int button, int action, float x, float y);
+extern void Android_OnMouse(SDL_Window* window, int button, int action, float x, float y);
 
 #endif /* _SDL_androidmouse_h */
 
--- SDL2.orig/src/video/android/SDL_androidtouch.c
+++ SDL2.new/src/video/android/SDL_androidtouch.c
@@ -40,12 +40,12 @@
 #define ACTION_POINTER_DOWN 5
 #define ACTION_POINTER_UP 6
 
-static void Android_GetWindowCoordinates(float x, float y,
+static void Android_GetWindowCoordinates(SDL_Window* window, float x, float y,
                                          int *window_x, int *window_y)
 {
     int window_w, window_h;
 
-    SDL_GetWindowSize(Android_Window, &window_w, &window_h);
+    SDL_GetWindowSize(window, &window_w, &window_h);
     *window_x = (int)(x * window_w);
     *window_y = (int)(y * window_h);
 }
@@ -56,12 +56,8 @@ static void
 SeparateEventsHintWatcher(void *userdata, const char *name,
                           const char *oldValue, const char *newValue)
 {
-    jclass mActivityClass = Android_JNI_GetActivityClass();
-    JNIEnv *env = Android_JNI_GetEnv();
-    jfieldID fid = (*env)->GetStaticFieldID(env, mActivityClass, "mSeparateMouseAndTouch", "Z");
-
     separate_mouse_and_touch = (newValue && (SDL_strcmp(newValue, "1") == 0));
-    (*env)->SetStaticBooleanField(env, mActivityClass, fid, separate_mouse_and_touch ? JNI_TRUE : JNI_FALSE);
+    Android_SetSeparateMouseAndTouchHint(separate_mouse_and_touch);
 }
 
 void Android_InitTouch(void)
@@ -88,17 +84,14 @@ void Android_QuitTouch(void)
     separate_mouse_and_touch = SDL_FALSE;
 }
 
-void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int action, float x, float y, float p)
-{
+
+void Android_OnTouch(SDL_Window* window, int touch_device_id_in, int pointer_finger_id_in,
+                     int action, float x, float y, float p) {
     SDL_TouchID touchDeviceId = 0;
     SDL_FingerID fingerId = 0;
     int window_x, window_y;
     static SDL_FingerID pointerFingerID = 0;
 
-    if (!Android_Window) {
-        return;
-    }
-
     touchDeviceId = (SDL_TouchID)touch_device_id_in;
     if (SDL_AddTouch(touchDeviceId, "") < 0) {
         SDL_Log("error: can't add touch %s, %d", __FILE__, __LINE__);
@@ -109,11 +102,11 @@ void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int actio
         case ACTION_DOWN:
             /* Primary pointer down */
             if (!separate_mouse_and_touch) {
-                Android_GetWindowCoordinates(x, y, &window_x, &window_y);
+                Android_GetWindowCoordinates(window, x, y, &window_x, &window_y);
                 /* send moved event */
-                SDL_SendMouseMotion(Android_Window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
+                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
                 /* send mouse down event */
-                SDL_SendMouseButton(Android_Window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
             }
             pointerFingerID = fingerId;
         case ACTION_POINTER_DOWN:
@@ -124,9 +117,9 @@ void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int actio
         case ACTION_MOVE:
             if (!pointerFingerID) {
                 if (!separate_mouse_and_touch) {
-                    Android_GetWindowCoordinates(x, y, &window_x, &window_y);
+                    Android_GetWindowCoordinates(window, x, y, &window_x, &window_y);
                     /* send moved event */
-                    SDL_SendMouseMotion(Android_Window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
+                    SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, window_x, window_y);
                 }
             }
             SDL_SendTouchMotion(touchDeviceId, fingerId, x, y, p);
@@ -136,7 +129,7 @@ void Android_OnTouch(int touch_device_id_in, int pointer_finger_id_in, int actio
             /* Primary pointer up */
             if (!separate_mouse_and_touch) {
                 /* send mouse up */
-                SDL_SendMouseButton(Android_Window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
+                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
             }
             pointerFingerID = (SDL_FingerID) 0;
         case ACTION_POINTER_UP:
--- SDL2.orig/src/video/android/SDL_androidtouch.h
+++ SDL2.new/src/video/android/SDL_androidtouch.h
@@ -24,6 +24,7 @@
 
 extern void Android_InitTouch(void);
 extern void Android_QuitTouch(void);
-extern void Android_OnTouch( int touch_device_id_in, int pointer_finger_id_in, int action, float x, float y, float p);
+extern void Android_OnTouch(SDL_Window* window, int touch_device_id_in, int pointer_finger_id_in,
+                            int action, float x, float y, float p);
 
 /* vi: set ts=4 sw=4 expandtab: */
--- SDL2.orig/src/video/android/SDL_androidvideo.c
+++ SDL2.new/src/video/android/SDL_androidvideo.c
@@ -57,10 +57,12 @@ extern int Android_GLES_LoadLibrary(_THIS, const char *path);
 #define Android_GLES_GetSwapInterval SDL_EGL_GetSwapInterval
 #define Android_GLES_DeleteContext SDL_EGL_DeleteContext
 
+extern int Android_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
+
 /* Android driver bootstrap functions */
 
 
-/* These are filled in with real values in Android_SetScreenResolution on init (before SDL_main()) */
+/* These are filled in with real values in SDL_Android_SetScreenDimensions on init (before SDL_main()) */
 int Android_ScreenWidth = 0;
 int Android_ScreenHeight = 0;
 Uint32 Android_ScreenFormat = SDL_PIXELFORMAT_UNKNOWN;
@@ -68,9 +70,6 @@ int Android_ScreenRate = 0;
 
 SDL_sem *Android_PauseSem = NULL, *Android_ResumeSem = NULL;
 
-/* Currently only one window */
-SDL_Window *Android_Window = NULL;
-
 static int
 Android_Available(void)
 {
@@ -90,6 +89,12 @@ Android_DeleteDevice(SDL_VideoDevice * device)
     SDL_free(device);
 }
 
+int Android_SetDisplayMode(_THIS, SDL_VideoDisplay* display, SDL_DisplayMode* mode) {
+//    Android_JNI_SetPixelFormat(jobject android_window, int pixelFormat);
+// TODO: Look into this
+    return 0;
+}
+
 static SDL_VideoDevice *
 Android_CreateDevice(int devindex)
 {
@@ -119,8 +124,13 @@ Android_CreateDevice(int devindex)
 
     device->CreateWindow = Android_CreateWindow;
     device->SetWindowTitle = Android_SetWindowTitle;
+    device->SetWindowIcon = Android_SetWindowIcon;
+    device->SetWindowSize = Android_SetWindowSize;
+    device->SetWindowPosition = Android_SetWindowPosition;
+    device->ShowWindow = Android_ShowWindow;
     device->DestroyWindow = Android_DestroyWindow;
     device->GetWindowWMInfo = Android_GetWindowWMInfo;
+    device->SetDisplayMode = Android_SetDisplayMode;
 
     device->free = Android_DeleteDevice;
 
@@ -166,6 +176,14 @@ Android_VideoInit(_THIS)
 {
     SDL_DisplayMode mode;
 
+    // Check if we are in an app process
+    if (Android_JNI_GetEnv() == NULL) {
+        return -1;
+    }
+    
+    if (!Android_PauseSem) Android_PauseSem = SDL_CreateSemaphore(0);
+    if (!Android_ResumeSem) Android_ResumeSem = SDL_CreateSemaphore(0);
+    
     mode.format = Android_ScreenFormat;
     mode.w = Android_ScreenWidth;
     mode.h = Android_ScreenHeight;
@@ -189,20 +207,28 @@ void
 Android_VideoQuit(_THIS)
 {
     Android_QuitTouch();
+    if (Android_PauseSem) SDL_DestroySemaphore(Android_PauseSem);
+    if (Android_ResumeSem) SDL_DestroySemaphore(Android_ResumeSem);
+    Android_PauseSem = NULL;
+    Android_ResumeSem = NULL;
 }
 
 /* This function gets called before VideoInit() */
-void
-Android_SetScreenResolution(int width, int height, Uint32 format, float rate)
+void SDL_Android_SetScreenDimensions(int width, int height, float rate)
 {
     Android_ScreenWidth = width;
     Android_ScreenHeight = height;
-    Android_ScreenFormat = format;
-    Android_ScreenRate = rate;
+    Android_ScreenRate = (int) rate;
+}
 
-    if (Android_Window) {
-        SDL_SendWindowEvent(Android_Window, SDL_WINDOWEVENT_RESIZED, width, height);
-    }
+void
+Android_SetWindowSurfaceResolution(SDL_Window* window, int width, int height, Uint32 format) // TODO: Global format?
+{
+    Android_ScreenFormat = format;
+    ((SDL_WindowData*) window->driverdata)->surface_w = width;
+    ((SDL_WindowData*) window->driverdata)->surface_h = height;
+    fprintf(stderr, "Window %d size changing to %dx%d\n", SDL_GetWindowID(window), width, height);
+    SDL_SendWindowEvent(window, SDL_WINDOWEVENT_RESIZED, width, height);
 }
 
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
--- SDL2.orig/src/video/android/SDL_androidvideo.h
+++ SDL2.new/src/video/android/SDL_androidvideo.h
@@ -27,8 +27,9 @@
 #include "SDL_rect.h"
 #include "../SDL_sysvideo.h"
 
-/* Called by the JNI layer when the screen changes size or format */
-extern void Android_SetScreenResolution(int width, int height, Uint32 format, float rate);
+/* Called by the JNI layer when a window surface changes size or format */
+extern void Android_SetWindowSurfaceResolution(SDL_Window* window, int width, int height, Uint32 format);
+extern void SDL_Android_SetScreenDimensions(int width, int height, float rate);
 
 /* Private display data */
 
@@ -41,7 +42,6 @@ extern int Android_ScreenWidth;
 extern int Android_ScreenHeight;
 extern Uint32 Android_ScreenFormat;
 extern SDL_sem *Android_PauseSem, *Android_ResumeSem;
-extern SDL_Window *Android_Window;
 
 
 #endif /* _SDL_androidvideo_h */
--- SDL2.orig/src/video/android/SDL_androidwindow.c
+++ SDL2.new/src/video/android/SDL_androidwindow.c
@@ -34,13 +34,6 @@ int
 Android_CreateWindow(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data;
-    
-    if (Android_Window) {
-        return SDL_SetError("Android only supports one window");
-    }
-    
-    Android_PauseSem = SDL_CreateSemaphore(0);
-    Android_ResumeSem = SDL_CreateSemaphore(0);
 
     /* Adjust the window data to match the screen */
     window->x = 0;
@@ -49,37 +42,34 @@ Android_CreateWindow(_THIS, SDL_Window * window)
     window->h = Android_ScreenHeight;
 
     window->flags &= ~SDL_WINDOW_RESIZABLE;     /* window is NEVER resizeable */
-    window->flags |= SDL_WINDOW_FULLSCREEN;     /* window is always fullscreen */
-    window->flags &= ~SDL_WINDOW_HIDDEN;
-    window->flags |= SDL_WINDOW_SHOWN;          /* only one window on Android */
-    window->flags |= SDL_WINDOW_INPUT_FOCUS;    /* always has input focus */
+    window->flags &= ~SDL_WINDOW_FULLSCREEN;     /* window is !not! always fullscreen (e.g. soft keyboard showing) */
+//    window->flags &= ~SDL_WINDOW_HIDDEN;
+//    window->flags |= SDL_WINDOW_SHOWN;          /* only one window on Android */
+//    window->flags |= SDL_WINDOW_INPUT_FOCUS;    /* always has input focus */
 
-    /* One window, it always has focus */
+    /* One window, it always has focus */ // TODO: Handle this
     SDL_SetMouseFocus(window);
-    SDL_SetKeyboardFocus(window);
     
     data = (SDL_WindowData *) SDL_calloc(1, sizeof(*data));
     if (!data) {
         return SDL_OutOfMemory();
     }
+    data->surface_w = Android_ScreenWidth;
+    data->surface_h = Android_ScreenHeight;
+    window->driverdata = data;
     
-    data->native_window = Android_JNI_GetNativeWindow();
+    data->android_window = NULL;
+    data->native_window = NULL;
+    data->egl_surface = SDL_EGL_CreateSurfaceWithoutWindow(_this);
     
-    if (!data->native_window) {
-        SDL_free(data);
-        return SDL_SetError("Could not fetch native window");
-    }
-    
-    data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);
-
     if (data->egl_surface == EGL_NO_SURFACE) {
-        ANativeWindow_release(data->native_window);
+        window->driverdata = NULL;
+        if (data->native_window) ANativeWindow_release(data->native_window);
+        data->native_window = NULL;
         SDL_free(data);
+        fprintf(stderr, "%s\n", SDL_GetError());
         return SDL_SetError("Could not create GLES window surface");
     }
-
-    window->driverdata = data;
-    Android_Window = window;
     
     return 0;
 }
@@ -87,32 +77,83 @@ Android_CreateWindow(_THIS, SDL_Window * window)
 void
 Android_SetWindowTitle(_THIS, SDL_Window * window)
 {
-    Android_JNI_SetActivityTitle(window->title);
+    Android_JNI_SetWindowTitle(window, window->title);
+}
+
+void
+Android_SetWindowIcon(_THIS, SDL_Window* window, SDL_Surface* icon) {
+    Android_JNI_SetWindowIcon(window, icon);
+}
+
+void
+Android_SetWindowSize(_THIS, SDL_Window* window) {
+    SDL_WindowData* data = window->driverdata;
+    if (window->w != data->surface_w || window->h != data->surface_h) {
+        window->w = data->surface_w;
+        window->h = data->surface_h;
+    }
+}
+
+void
+Android_SetWindowPosition(_THIS, SDL_Window *window) {
+    window->x = 0; // TODO: Maybe allow the window manager to actually handle this
+    window->y = 0;
+}
+
+void Android_ShowWindow(_THIS, SDL_Window *window) {
+    SDL_WindowData* data = window->driverdata;
+    data->android_window = Android_JNI_CreateWindow(window);
+    if (data->android_window == NULL) {
+        window->driverdata = NULL;
+        SDL_free(data);
+        SDL_SetError("Failed to create Android window");
+        return;
+    }
+    
+    data->native_window = Android_JNI_GetNativeWindow(data->android_window);
+    
+    if (!data->native_window) {
+        window->driverdata = NULL;
+        SDL_free(data);
+        SDL_SetError("Could not fetch native window");
+        return;
+    }
+    
+    EGLSurface* oldSurface = data->egl_surface;
+    
+    data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType) data->native_window);
+    if (data->egl_surface == EGL_NO_SURFACE) {
+        window->driverdata = NULL;
+        if (data->native_window) ANativeWindow_release(data->native_window);
+        data->native_window = NULL;
+        SDL_free(data);
+        fprintf(stderr, "%s\n", SDL_GetError());
+        SDL_SetError("Could not create GLES window surface");
+        return;
+    }
+    
+    if (oldSurface != EGL_NO_SURFACE) {
+        SDL_EGL_DestroySurface(_this, oldSurface);
+    }
 }
 
 void
 Android_DestroyWindow(_THIS, SDL_Window * window)
 {
     SDL_WindowData *data;
-    
-    if (window == Android_Window) {
-        Android_Window = NULL;
-        if (Android_PauseSem) SDL_DestroySemaphore(Android_PauseSem);
-        if (Android_ResumeSem) SDL_DestroySemaphore(Android_ResumeSem);
-        Android_PauseSem = NULL;
-        Android_ResumeSem = NULL;
-        
-        if(window->driverdata) {
-            data = (SDL_WindowData *) window->driverdata;
-            if (data->egl_surface != EGL_NO_SURFACE) {
-                SDL_EGL_DestroySurface(_this, data->egl_surface);
-            }
-            if (data->native_window) {
-                ANativeWindow_release(data->native_window);
-            }
-            SDL_free(window->driverdata);
-            window->driverdata = NULL;
+    if(window->driverdata) {
+        data = (SDL_WindowData *) window->driverdata;
+        if (data->egl_surface != EGL_NO_SURFACE) {
+            SDL_EGL_DestroySurface(_this, data->egl_surface);
         }
+        if (data->native_window) {
+            ANativeWindow_release(data->native_window);
+        }
+        if (data->android_window) {
+            Android_JNI_DestroyWindow(data->android_window);
+        }
+        SDL_free(window->driverdata);
+        window->driverdata = NULL;
     }
 }
 
--- SDL2.orig/src/video/android/SDL_androidwindow.h
+++ SDL2.new/src/video/android/SDL_androidwindow.h
@@ -25,9 +25,15 @@
 
 #include "../../core/android/SDL_android.h"
 #include "../SDL_egl_c.h"
+#include "jni.h"
+#define GET_ANDROID_WINDOW(sdlWindow) (((SDL_WindowData*) sdlWindow->driverdata)->android_window)
 
 extern int Android_CreateWindow(_THIS, SDL_Window * window);
 extern void Android_SetWindowTitle(_THIS, SDL_Window * window);
+extern void Android_SetWindowIcon(_THIS, SDL_Window* window, SDL_Surface* icon);
+extern void Android_SetWindowSize(_THIS, SDL_Window* window);
+extern void Android_SetWindowPosition(_THIS, SDL_Window *window);
+extern void Android_ShowWindow(_THIS, SDL_Window *window);
 extern void Android_DestroyWindow(_THIS, SDL_Window * window);
 extern SDL_bool Android_GetWindowWMInfo(_THIS, SDL_Window * window, struct SDL_SysWMinfo * info);
 
@@ -36,6 +42,9 @@ typedef struct
     EGLSurface egl_surface;
     EGLContext egl_context; /* We use this to preserve the context when losing focus */
     ANativeWindow* native_window;
+    jobject android_window;
+    int surface_w;
+    int surface_h;
     
 } SDL_WindowData;
 
